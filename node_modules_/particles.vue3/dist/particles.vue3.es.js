import { defineComponent as Ot, nextTick as Rt, openBlock as Ft, createElementBlock as It } from "vue";
var nt = globalThis && globalThis.__classPrivateFieldSet || function(n, e, t, i, s) {
  if (i === "m")
    throw new TypeError("Private method is not writable");
  if (i === "a" && !s)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof e == "function" ? n !== e || !s : !e.has(n))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return i === "a" ? s.call(n, t) : s ? s.value = t : e.set(n, t), t;
}, N = globalThis && globalThis.__classPrivateFieldGet || function(n, e, t, i) {
  if (t === "a" && !i)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof e == "function" ? n !== e || !i : !e.has(n))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return t === "m" ? i : t === "a" ? i.call(n) : i ? i.value : e.get(n);
}, I;
class At {
  constructor() {
    I.set(this, void 0), nt(this, I, /* @__PURE__ */ new Map(), "f");
  }
  addEventListener(e, t) {
    var i;
    this.removeEventListener(e, t), N(this, I, "f").get(e) || N(this, I, "f").set(e, []), (i = N(this, I, "f").get(e)) === null || i === void 0 || i.push(t);
  }
  dispatchEvent(e, t) {
    var i;
    (i = N(this, I, "f").get(e)) === null || i === void 0 || i.forEach((s) => s(t));
  }
  hasEventListener(e) {
    return !!N(this, I, "f").get(e);
  }
  removeAllEventListeners(e) {
    e ? N(this, I, "f").delete(e) : nt(this, I, /* @__PURE__ */ new Map(), "f");
  }
  removeEventListener(e, t) {
    const i = N(this, I, "f").get(e);
    if (!i)
      return;
    const s = i.length, o = i.indexOf(t);
    o < 0 || (s === 1 ? N(this, I, "f").delete(e) : i.splice(o, 1));
  }
}
I = /* @__PURE__ */ new WeakMap();
class R {
  constructor(e, t) {
    if (typeof e != "number" && e)
      this.x = e.x, this.y = e.y;
    else if (e !== void 0 && t !== void 0)
      this.x = e, this.y = t;
    else
      throw new Error("tsParticles - Vector not initialized correctly");
  }
  static get origin() {
    return R.create(0, 0);
  }
  get angle() {
    return Math.atan2(this.y, this.x);
  }
  set angle(e) {
    this.updateFromAngle(e, this.length);
  }
  get length() {
    return Math.sqrt(this.getLengthSq());
  }
  set length(e) {
    this.updateFromAngle(this.angle, e);
  }
  static clone(e) {
    return R.create(e.x, e.y);
  }
  static create(e, t) {
    return new R(e, t);
  }
  add(e) {
    return R.create(this.x + e.x, this.y + e.y);
  }
  addTo(e) {
    this.x += e.x, this.y += e.y;
  }
  copy() {
    return R.clone(this);
  }
  distanceTo(e) {
    return this.sub(e).length;
  }
  distanceToSq(e) {
    return this.sub(e).getLengthSq();
  }
  div(e) {
    return R.create(this.x / e, this.y / e);
  }
  divTo(e) {
    this.x /= e, this.y /= e;
  }
  getLengthSq() {
    return this.x ** 2 + this.y ** 2;
  }
  manhattanDistanceTo(e) {
    return Math.abs(e.x - this.x) + Math.abs(e.y - this.y);
  }
  mult(e) {
    return R.create(this.x * e, this.y * e);
  }
  multTo(e) {
    this.x *= e, this.y *= e;
  }
  rotate(e) {
    return R.create(this.x * Math.cos(e) - this.y * Math.sin(e), this.x * Math.sin(e) + this.y * Math.cos(e));
  }
  setTo(e) {
    this.x = e.x, this.y = e.y;
  }
  sub(e) {
    return R.create(this.x - e.x, this.y - e.y);
  }
  subFrom(e) {
    this.x -= e.x, this.y -= e.y;
  }
  updateFromAngle(e, t) {
    this.x = Math.cos(e) * t, this.y = Math.sin(e) * t;
  }
}
let Dt = Math.random;
function W() {
  return _t(Dt(), 0, 1 - 1e-16);
}
function _t(n, e, t) {
  return Math.min(Math.max(n, e), t);
}
function j(n) {
  const e = De(n);
  let t = Ae(n);
  return e === t && (t = 0), W() * (e - t) + t;
}
function b(n) {
  return typeof n == "number" ? n : j(n);
}
function Ae(n) {
  return typeof n == "number" ? n : n.min;
}
function De(n) {
  return typeof n == "number" ? n : n.max;
}
function y(n, e) {
  if (n === e || e === void 0 && typeof n == "number")
    return n;
  const t = Ae(n), i = De(n);
  return e !== void 0 ? {
    min: Math.min(t, e),
    max: Math.max(i, e)
  } : y(t, i);
}
function Ue(n) {
  const e = n.random, { enable: t, minimumValue: i } = typeof e == "boolean" ? {
    enable: e,
    minimumValue: 0
  } : e;
  return b(t ? y(n.value, i) : n.value);
}
function Lt(n, e) {
  const t = n.x - e.x, i = n.y - e.y;
  return { dx: t, dy: i, distance: Math.sqrt(t * t + i * i) };
}
function Ke(n, e) {
  return Lt(n, e).distance;
}
function Wt(n, e, t) {
  if (typeof n == "number")
    return n * Math.PI / 180;
  switch (n) {
    case "top":
      return -Math.PI / 2;
    case "top-right":
      return -Math.PI / 4;
    case "right":
      return 0;
    case "bottom-right":
      return Math.PI / 4;
    case "bottom":
      return Math.PI / 2;
    case "bottom-left":
      return 3 * Math.PI / 4;
    case "left":
      return Math.PI;
    case "top-left":
      return -3 * Math.PI / 4;
    case "inside":
      return Math.atan2(t.y - e.y, t.x - e.x);
    case "outside":
      return Math.atan2(e.y - t.y, e.x - t.x);
    case "none":
    default:
      return W() * Math.PI * 2;
  }
}
function Ht(n) {
  const e = R.origin;
  return e.length = 1, e.angle = n, e;
}
function Vt(n) {
  var e, t;
  return ((e = n.position) === null || e === void 0 ? void 0 : e.x) !== void 0 && ((t = n.position) === null || t === void 0 ? void 0 : t.y) !== void 0 ? {
    x: n.position.x * n.size.width / 100,
    y: n.position.y * n.size.height / 100
  } : void 0;
}
function $t(n) {
  var e, t, i, s;
  return {
    x: (t = (e = n.position) === null || e === void 0 ? void 0 : e.x) !== null && t !== void 0 ? t : W() * n.size.width,
    y: (s = (i = n.position) === null || i === void 0 ? void 0 : i.y) !== null && s !== void 0 ? s : W() * n.size.height
  };
}
function Pt(n) {
  return n.endsWith("%") ? parseFloat(n) / 100 : parseFloat(n);
}
function Te() {
  return typeof window > "u" || !window || typeof window.document > "u" || !window.document;
}
function qt() {
  return Te() ? (n) => setTimeout(n) : (n) => (window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || window.setTimeout)(n);
}
function Gt() {
  return Te() ? (n) => clearTimeout(n) : (n) => (window.cancelAnimationFrame || window.webkitCancelRequestAnimationFrame || window.mozCancelRequestAnimationFrame || window.oCancelRequestAnimationFrame || window.msCancelRequestAnimationFrame || window.clearTimeout)(n);
}
function ot(n, e) {
  return n === e || e instanceof Array && e.indexOf(n) > -1;
}
function jt(n) {
  return Math.floor(W() * n.length);
}
function Z(n, e, t = !0) {
  const i = e !== void 0 && t ? e % n.length : jt(n);
  return n[i];
}
function z(n, ...e) {
  for (const t of e) {
    if (t == null)
      continue;
    if (typeof t != "object") {
      n = t;
      continue;
    }
    const i = Array.isArray(t);
    i && (typeof n != "object" || !n || !Array.isArray(n)) ? n = [] : !i && (typeof n != "object" || !n || Array.isArray(n)) && (n = {});
    for (const s in t) {
      if (s === "__proto__")
        continue;
      const o = t, r = o[s], a = typeof r == "object", l = n;
      l[s] = a && Array.isArray(r) ? r.map((c) => z(l[s], c)) : z(l[s], r);
    }
  }
  return n;
}
const Bt = "random", Le = /* @__PURE__ */ new Map();
function xt(n, e) {
  Le.set(n, e);
}
function He(n, e, t) {
  return t < 0 && (t += 1), t > 1 && (t -= 1), t < 1 / 6 ? n + (e - n) * 6 * t : t < 1 / 2 ? e : t < 2 / 3 ? n + (e - n) * (2 / 3 - t) * 6 : n;
}
function Nt(n) {
  for (const [, o] of Le)
    if (n.startsWith(o.stringPrefix))
      return o.parseString(n);
  const e = /^#?([a-f\d])([a-f\d])([a-f\d])([a-f\d])?$/i, t = n.replace(e, (o, r, a, l, c) => r + r + a + a + l + l + (c !== void 0 ? c + c : "")), i = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})?$/i, s = i.exec(t);
  return s ? {
    a: s[4] !== void 0 ? parseInt(s[4], 16) / 255 : 1,
    b: parseInt(s[3], 16),
    g: parseInt(s[2], 16),
    r: parseInt(s[1], 16)
  } : void 0;
}
function de(n, e, t = !0) {
  if (!n)
    return;
  const i = typeof n == "string" ? { value: n } : n;
  if (typeof i.value == "string")
    return zt(i.value, e, t);
  if (i.value instanceof Array)
    return de({
      value: Z(i.value, e, t)
    });
  for (const [, s] of Le) {
    const o = s.handleRangeColor(i);
    if (o)
      return o;
  }
}
function zt(n, e, t = !0) {
  if (!n)
    return;
  const i = typeof n == "string" ? { value: n } : n;
  if (typeof i.value == "string")
    return i.value === Bt ? Jt() : Xt(i.value);
  if (i.value instanceof Array)
    return zt({
      value: Z(i.value, e, t)
    });
  for (const [, s] of Le) {
    const o = s.handleColor(i);
    if (o)
      return o;
  }
}
function rt(n, e, t = !0) {
  const i = de(n, e, t);
  return i ? Ut(i) : void 0;
}
function Ut(n) {
  const e = n.r / 255, t = n.g / 255, i = n.b / 255, s = Math.max(e, t, i), o = Math.min(e, t, i), r = {
    h: 0,
    l: (s + o) / 2,
    s: 0
  };
  return s !== o && (r.s = r.l < 0.5 ? (s - o) / (s + o) : (s - o) / (2 - s - o), r.h = e === s ? (t - i) / (s - o) : r.h = t === s ? 2 + (i - e) / (s - o) : 4 + (e - t) / (s - o)), r.l *= 100, r.s *= 100, r.h *= 60, r.h < 0 && (r.h += 360), r.h >= 360 && (r.h -= 360), r;
}
function Xt(n) {
  return Nt(n);
}
function Xe(n) {
  const e = { b: 0, g: 0, r: 0 }, t = {
    h: n.h / 360,
    l: n.l / 100,
    s: n.s / 100
  };
  if (!t.s)
    e.b = t.l, e.g = t.l, e.r = t.l;
  else {
    const i = t.l < 0.5 ? t.l * (1 + t.s) : t.l + t.s - t.l * t.s, s = 2 * t.l - i;
    e.r = He(s, i, t.h + 1 / 3), e.g = He(s, i, t.h), e.b = He(s, i, t.h - 1 / 3);
  }
  return e.r = Math.floor(e.r * 255), e.g = Math.floor(e.g * 255), e.b = Math.floor(e.b * 255), e;
}
function Yt(n) {
  const e = Xe(n);
  return {
    a: n.a,
    b: e.b,
    g: e.g,
    r: e.r
  };
}
function Jt(n) {
  const e = n != null ? n : 0;
  return {
    b: Math.floor(j(y(e, 256))),
    g: Math.floor(j(y(e, 256))),
    r: Math.floor(j(y(e, 256)))
  };
}
function Ee(n, e) {
  return `rgba(${n.r}, ${n.g}, ${n.b}, ${e != null ? e : 1})`;
}
function at(n, e) {
  return `hsla(${n.h}, ${n.s}%, ${n.l}%, ${e != null ? e : 1})`;
}
function lt(n) {
  return n !== void 0 ? {
    h: n.h.value,
    s: n.s.value,
    l: n.l.value
  } : void 0;
}
function Zt(n, e, t) {
  n.save(), n.fillStyle = t != null ? t : "rgba(0,0,0,0)", n.fillRect(0, 0, e.width, e.height), n.restore();
}
function Ve(n, e) {
  n.clearRect(0, 0, e.width, e.height);
}
function Qt(n) {
  var e, t, i, s, o, r, a, l, c, u;
  const { container: d, context: h, particle: p, delta: f, colorStyles: v, backgroundMask: m, composite: w, radius: M, opacity: A, shadow: C, transform: _ } = n, E = p.getPosition();
  h.save(), _.a !== void 0 || _.b !== void 0 || _.c !== void 0 || _.d !== void 0 ? h.setTransform((e = _.a) !== null && e !== void 0 ? e : 1, (t = _.b) !== null && t !== void 0 ? t : 0, (i = _.c) !== null && i !== void 0 ? i : 0, (s = _.d) !== null && s !== void 0 ? s : 1, E.x, E.y) : h.translate(E.x, E.y), h.beginPath();
  const k = p.rotation + (p.options.rotate.path ? p.velocity.angle : 0);
  k !== 0 && h.rotate(k), m && (h.globalCompositeOperation = w);
  const fe = p.shadowColor;
  C.enable && fe && (h.shadowBlur = C.blur, h.shadowColor = Ee(fe), h.shadowOffsetX = C.offset.x, h.shadowOffsetY = C.offset.y), v.fill && (h.fillStyle = v.fill);
  const B = p.stroke;
  h.lineWidth = (o = p.strokeWidth) !== null && o !== void 0 ? o : 0, v.stroke && (h.strokeStyle = v.stroke), Kt(d, h, p, M, A, f), ((r = B == null ? void 0 : B.width) !== null && r !== void 0 ? r : 0) > 0 && h.stroke(), p.close && h.closePath(), p.fill && h.fill(), h.restore(), h.save(), _.a !== void 0 || _.b !== void 0 || _.c !== void 0 || _.d !== void 0 ? h.setTransform((a = _.a) !== null && a !== void 0 ? a : 1, (l = _.b) !== null && l !== void 0 ? l : 0, (c = _.c) !== null && c !== void 0 ? c : 0, (u = _.d) !== null && u !== void 0 ? u : 1, E.x, E.y) : h.translate(E.x, E.y), p.rotation && h.rotate(p.rotation), m && (h.globalCompositeOperation = w), ei(d, h, p, M, A, f), h.restore();
}
function Kt(n, e, t, i, s, o) {
  if (!t.shape)
    return;
  const r = n.drawers.get(t.shape);
  !r || r.draw(e, t, i, s, o, n.retina.pixelRatio);
}
function ei(n, e, t, i, s, o) {
  if (!t.shape)
    return;
  const r = n.drawers.get(t.shape);
  !(r != null && r.afterEffect) || r.afterEffect(e, t, i, s, o, n.retina.pixelRatio);
}
function ti(n, e, t) {
  !e.draw || (n.save(), e.draw(n, t), n.restore());
}
function ii(n, e, t, i) {
  !e.drawParticle || (n.save(), e.drawParticle(n, t, i), n.restore());
}
function si(n, e, t) {
  return {
    h: n.h,
    s: n.s,
    l: n.l + (e === "darken" ? -1 : 1) * t
  };
}
const Me = "generated", ht = "touchend", ni = "mousedown", oi = "mouseup", ct = "mousemove", ri = "touchstart", ai = "touchmove", ut = "mouseleave", li = "mouseout", hi = "touchcancel", ci = "resize", ui = "visibilitychange";
var O = globalThis && globalThis.__classPrivateFieldSet || function(n, e, t, i, s) {
  if (i === "m")
    throw new TypeError("Private method is not writable");
  if (i === "a" && !s)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof e == "function" ? n !== e || !s : !e.has(n))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return i === "a" ? s.call(n, t) : s ? s.value = t : e.set(n, t), t;
}, V = globalThis && globalThis.__classPrivateFieldGet || function(n, e, t, i) {
  if (t === "a" && !i)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof e == "function" ? n !== e || !i : !e.has(n))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return t === "m" ? i : t === "a" ? i.call(n) : i ? i.value : e.get(n);
}, re, ae, K, ee, te;
function di(n, e, t) {
  var i;
  const s = e[t];
  s !== void 0 && (n[t] = ((i = n[t]) !== null && i !== void 0 ? i : 1) * s);
}
class fi {
  constructor(e) {
    this.container = e, re.set(this, void 0), ae.set(this, void 0), K.set(this, void 0), ee.set(this, void 0), te.set(this, void 0), this.size = {
      height: 0,
      width: 0
    }, O(this, ae, null, "f"), this.generatedCanvas = !1, O(this, ee, [], "f"), O(this, K, [], "f"), O(this, te, [], "f"), O(this, re, [], "f");
  }
  clear() {
    const e = this.container.actualOptions, t = e.particles.move.trail;
    e.backgroundMask.enable ? this.paint() : t.enable && t.length > 0 && this.trailFillColor ? this.paintBase(Ee(this.trailFillColor, 1 / t.length)) : this.draw((i) => {
      Ve(i, this.size);
    });
  }
  destroy() {
    var e;
    this.generatedCanvas ? (e = this.element) === null || e === void 0 || e.remove() : this.resetOriginalStyle(), this.draw((t) => {
      Ve(t, this.size);
    }), O(this, ee, [], "f"), O(this, K, [], "f"), O(this, te, [], "f"), O(this, re, [], "f");
  }
  draw(e) {
    if (!!V(this, ae, "f"))
      return e(V(this, ae, "f"));
  }
  drawParticle(e, t) {
    var i;
    if (e.spawning || e.destroyed)
      return;
    const s = e.getRadius();
    if (s <= 0)
      return;
    const o = e.getFillColor(), r = (i = e.getStrokeColor()) !== null && i !== void 0 ? i : o;
    let [a, l] = this.getPluginParticleColors(e);
    a || (a = o), l || (l = r), !(!a && !l) && this.draw((c) => {
      var u, d, h, p, f;
      const v = this.container.actualOptions, m = e.options.zIndex, w = (1 - e.zIndexFactor) ** m.opacityRate, M = (h = (u = e.bubble.opacity) !== null && u !== void 0 ? u : (d = e.opacity) === null || d === void 0 ? void 0 : d.value) !== null && h !== void 0 ? h : 1, A = (f = (p = e.stroke) === null || p === void 0 ? void 0 : p.opacity) !== null && f !== void 0 ? f : M, C = M * w, _ = A * w, E = {}, k = {
        fill: a ? at(a, C) : void 0
      };
      k.stroke = l ? at(l, _) : k.fill, this.applyPreDrawUpdaters(c, e, s, C, k, E), Qt({
        container: this.container,
        context: c,
        particle: e,
        delta: t,
        colorStyles: k,
        backgroundMask: v.backgroundMask.enable,
        composite: v.backgroundMask.composite,
        radius: s * (1 - e.zIndexFactor) ** m.sizeRate,
        opacity: C,
        shadow: e.options.shadow,
        transform: E
      }), this.applyPostDrawUpdaters(e);
    });
  }
  drawParticlePlugin(e, t, i) {
    this.draw((s) => {
      ii(s, e, t, i);
    });
  }
  drawPlugin(e, t) {
    this.draw((i) => {
      ti(i, e, t);
    });
  }
  init() {
    this.resize(), this.initStyle(), this.initCover(), this.initTrail(), this.initBackground(), this.initUpdaters(), this.initPlugins(), this.paint();
  }
  initBackground() {
    const e = this.container.actualOptions, t = e.background, i = this.element, s = i == null ? void 0 : i.style;
    if (!!s) {
      if (t.color) {
        const o = de(t.color);
        s.backgroundColor = o ? Ee(o, t.opacity) : "";
      } else
        s.backgroundColor = "";
      s.backgroundImage = t.image || "", s.backgroundPosition = t.position || "", s.backgroundRepeat = t.repeat || "", s.backgroundSize = t.size || "";
    }
  }
  initPlugins() {
    O(this, te, [], "f");
    for (const [, e] of this.container.plugins)
      e.resize && V(this, te, "f").push(e), (e.particleFillColor || e.particleStrokeColor) && V(this, re, "f").push(e);
  }
  initUpdaters() {
    O(this, ee, [], "f"), O(this, K, [], "f");
    for (const e of this.container.particles.updaters)
      e.afterDraw && V(this, K, "f").push(e), (e.getColorStyles || e.getTransformValues || e.beforeDraw) && V(this, ee, "f").push(e);
  }
  loadCanvas(e) {
    var t;
    this.generatedCanvas && ((t = this.element) === null || t === void 0 || t.remove()), this.generatedCanvas = e.dataset && Me in e.dataset ? e.dataset[Me] === "true" : this.generatedCanvas, this.element = e, this.originalStyle = z({}, this.element.style), this.size.height = e.offsetHeight, this.size.width = e.offsetWidth, O(this, ae, this.element.getContext("2d"), "f"), this.container.retina.init(), this.initBackground();
  }
  paint() {
    const e = this.container.actualOptions;
    this.draw((t) => {
      e.backgroundMask.enable && e.backgroundMask.cover ? (Ve(t, this.size), this.paintBase(this.coverColorStyle)) : this.paintBase();
    });
  }
  resize() {
    if (!this.element)
      return;
    const e = this.container, t = e.retina.pixelRatio, i = e.canvas.size, s = {
      width: this.element.offsetWidth * t,
      height: this.element.offsetHeight * t
    };
    if (s.height === i.height && s.width === i.width && s.height === this.element.height && s.width === this.element.width)
      return;
    const o = Object.assign({}, i);
    this.element.width = i.width = this.element.offsetWidth * t, this.element.height = i.height = this.element.offsetHeight * t, this.container.started && (this.resizeFactor = {
      width: i.width / o.width,
      height: i.height / o.height
    });
  }
  async windowResize() {
    if (!this.element)
      return;
    this.resize();
    const e = this.container, t = e.updateActualOptions();
    e.particles.setDensity(), this.applyResizePlugins(), t && await e.refresh();
  }
  applyPostDrawUpdaters(e) {
    var t;
    for (const i of V(this, K, "f"))
      (t = i.afterDraw) === null || t === void 0 || t.call(i, e);
  }
  applyPreDrawUpdaters(e, t, i, s, o, r) {
    var a;
    for (const l of V(this, ee, "f")) {
      if (l.getColorStyles) {
        const { fill: c, stroke: u } = l.getColorStyles(t, e, i, s);
        c && (o.fill = c), u && (o.stroke = u);
      }
      if (l.getTransformValues) {
        const c = l.getTransformValues(t);
        for (const u in c)
          di(r, c, u);
      }
      (a = l.beforeDraw) === null || a === void 0 || a.call(l, t);
    }
  }
  applyResizePlugins() {
    var e;
    for (const t of V(this, te, "f"))
      (e = t.resize) === null || e === void 0 || e.call(t);
  }
  getPluginParticleColors(e) {
    let t, i;
    for (const s of V(this, re, "f"))
      if (!t && s.particleFillColor && (t = rt(s.particleFillColor(e))), !i && s.particleStrokeColor && (i = rt(s.particleStrokeColor(e))), t && i)
        break;
    return [t, i];
  }
  initCover() {
    const e = this.container.actualOptions, t = e.backgroundMask.cover, i = t.color, s = de(i);
    if (s) {
      const o = {
        r: s.r,
        g: s.g,
        b: s.b,
        a: t.opacity
      };
      this.coverColorStyle = Ee(o, o.a);
    }
  }
  initStyle() {
    const e = this.element, t = this.container.actualOptions;
    if (!!e) {
      t.fullScreen.enable ? (this.originalStyle = z({}, e.style), e.style.setProperty("position", "fixed", "important"), e.style.setProperty("z-index", t.fullScreen.zIndex.toString(10), "important"), e.style.setProperty("top", "0", "important"), e.style.setProperty("left", "0", "important"), e.style.setProperty("width", "100%", "important"), e.style.setProperty("height", "100%", "important")) : this.resetOriginalStyle();
      for (const i in t.style) {
        if (!i || !t.style)
          continue;
        const s = t.style[i];
        !s || e.style.setProperty(i, s, "important");
      }
    }
  }
  initTrail() {
    const e = this.container.actualOptions, t = e.particles.move.trail, i = de(t.fillColor);
    if (i) {
      const s = e.particles.move.trail;
      this.trailFillColor = {
        r: i.r,
        g: i.g,
        b: i.b,
        a: 1 / s.length
      };
    }
  }
  paintBase(e) {
    this.draw((t) => {
      Zt(t, this.size, e);
    });
  }
  resetOriginalStyle() {
    const e = this.element, t = this.originalStyle;
    e && t && (e.style.position = t.position, e.style.zIndex = t.zIndex, e.style.top = t.top, e.style.left = t.left, e.style.width = t.width, e.style.height = t.height);
  }
}
re = /* @__PURE__ */ new WeakMap(), ae = /* @__PURE__ */ new WeakMap(), K = /* @__PURE__ */ new WeakMap(), ee = /* @__PURE__ */ new WeakMap(), te = /* @__PURE__ */ new WeakMap();
function F(n, e, t, i, s) {
  if (i) {
    let o = { passive: !0 };
    typeof s == "boolean" ? o.capture = s : s !== void 0 && (o = s), n.addEventListener(e, t, o);
  } else {
    const o = s;
    n.removeEventListener(e, t, o);
  }
}
class pi {
  constructor(e) {
    this.container = e, this.canPush = !0, this.mouseMoveHandler = (t) => this.mouseTouchMove(t), this.touchStartHandler = (t) => this.mouseTouchMove(t), this.touchMoveHandler = (t) => this.mouseTouchMove(t), this.touchEndHandler = () => this.mouseTouchFinish(), this.mouseLeaveHandler = () => this.mouseTouchFinish(), this.touchCancelHandler = () => this.mouseTouchFinish(), this.touchEndClickHandler = (t) => this.mouseTouchClick(t), this.mouseUpHandler = (t) => this.mouseTouchClick(t), this.mouseDownHandler = () => this.mouseDown(), this.visibilityChangeHandler = () => this.handleVisibilityChange(), this.themeChangeHandler = (t) => this.handleThemeChange(t), this.oldThemeChangeHandler = (t) => this.handleThemeChange(t), this.resizeHandler = () => this.handleWindowResize();
  }
  addListeners() {
    this.manageListeners(!0);
  }
  removeListeners() {
    this.manageListeners(!1);
  }
  doMouseTouchClick(e) {
    const t = this.container, i = t.actualOptions;
    if (this.canPush) {
      const s = t.interactivity.mouse.position;
      if (!s)
        return;
      t.interactivity.mouse.clickPosition = {
        x: s.x,
        y: s.y
      }, t.interactivity.mouse.clickTime = new Date().getTime();
      const o = i.interactivity.events.onClick;
      if (o.mode instanceof Array)
        for (const r of o.mode)
          this.handleClickMode(r);
      else
        this.handleClickMode(o.mode);
    }
    e.type === "touchend" && setTimeout(() => this.mouseTouchFinish(), 500);
  }
  handleClickMode(e) {
    this.container.handleClickMode(e);
  }
  handleThemeChange(e) {
    const t = e, i = t.matches ? this.container.options.defaultDarkTheme : this.container.options.defaultLightTheme, s = this.container.options.themes.find((o) => o.name === i);
    s && s.default.auto && this.container.loadTheme(i);
  }
  handleVisibilityChange() {
    const e = this.container, t = e.actualOptions;
    this.mouseTouchFinish(), t.pauseOnBlur && (document != null && document.hidden ? (e.pageHidden = !0, e.pause()) : (e.pageHidden = !1, e.getAnimationStatus() ? e.play(!0) : e.draw(!0)));
  }
  handleWindowResize() {
    this.resizeTimeout && (clearTimeout(this.resizeTimeout), delete this.resizeTimeout), this.resizeTimeout = setTimeout(async () => {
      var e;
      return (e = this.container.canvas) === null || e === void 0 ? void 0 : e.windowResize();
    }, 500);
  }
  manageListeners(e) {
    var t;
    const i = this.container, s = i.actualOptions, o = s.interactivity.detectsOn;
    let r = ut;
    if (o === "window")
      i.interactivity.element = window, r = li;
    else if (o === "parent" && i.canvas.element) {
      const u = i.canvas.element;
      i.interactivity.element = (t = u.parentElement) !== null && t !== void 0 ? t : u.parentNode;
    } else
      i.interactivity.element = i.canvas.element;
    const a = !Te() && typeof matchMedia < "u" && matchMedia("(prefers-color-scheme: dark)");
    a && (a.addEventListener !== void 0 ? F(a, "change", this.themeChangeHandler, e) : a.addListener !== void 0 && (e ? a.addListener(this.oldThemeChangeHandler) : a.removeListener(this.oldThemeChangeHandler)));
    const l = i.interactivity.element;
    if (!l)
      return;
    const c = l;
    (s.interactivity.events.onHover.enable || s.interactivity.events.onClick.enable) && (F(l, ct, this.mouseMoveHandler, e), F(l, ri, this.touchStartHandler, e), F(l, ai, this.touchMoveHandler, e), s.interactivity.events.onClick.enable ? (F(l, ht, this.touchEndClickHandler, e), F(l, oi, this.mouseUpHandler, e), F(l, ni, this.mouseDownHandler, e)) : F(l, ht, this.touchEndHandler, e), F(l, r, this.mouseLeaveHandler, e), F(l, hi, this.touchCancelHandler, e)), i.canvas.element && (i.canvas.element.style.pointerEvents = c === i.canvas.element ? "initial" : "none"), s.interactivity.events.resize && (typeof ResizeObserver < "u" ? this.resizeObserver && !e ? (i.canvas.element && this.resizeObserver.unobserve(i.canvas.element), this.resizeObserver.disconnect(), delete this.resizeObserver) : !this.resizeObserver && e && i.canvas.element && (this.resizeObserver = new ResizeObserver((u) => {
      !u.find((h) => h.target === i.canvas.element) || this.handleWindowResize();
    }), this.resizeObserver.observe(i.canvas.element)) : F(window, ci, this.resizeHandler, e)), document && F(document, ui, this.visibilityChangeHandler, e, !1);
  }
  mouseDown() {
    const e = this.container.interactivity;
    if (e) {
      const t = e.mouse;
      t.clicking = !0, t.downPosition = t.position;
    }
  }
  mouseTouchClick(e) {
    const t = this.container, i = t.actualOptions, s = t.interactivity.mouse;
    s.inside = !0;
    let o = !1;
    const r = s.position;
    if (!(!r || !i.interactivity.events.onClick.enable)) {
      for (const [, a] of t.plugins)
        if (!!a.clickPositionValid && (o = a.clickPositionValid(r), o))
          break;
      o || this.doMouseTouchClick(e), s.clicking = !1;
    }
  }
  mouseTouchFinish() {
    const e = this.container.interactivity;
    if (!e)
      return;
    const t = e.mouse;
    delete t.position, delete t.clickPosition, delete t.downPosition, e.status = ut, t.inside = !1, t.clicking = !1;
  }
  mouseTouchMove(e) {
    var t, i, s, o, r, a, l;
    const c = this.container, u = c.actualOptions;
    if (!(!((t = c.interactivity) === null || t === void 0) && t.element))
      return;
    c.interactivity.mouse.inside = !0;
    let d;
    const h = c.canvas.element;
    if (e.type.startsWith("mouse")) {
      this.canPush = !0;
      const f = e;
      if (c.interactivity.element === window) {
        if (h) {
          const v = h.getBoundingClientRect();
          d = {
            x: f.clientX - v.left,
            y: f.clientY - v.top
          };
        }
      } else if (u.interactivity.detectsOn === "parent") {
        const v = f.target, m = f.currentTarget, w = c.canvas.element;
        if (v && m && w) {
          const M = v.getBoundingClientRect(), A = m.getBoundingClientRect(), C = w.getBoundingClientRect();
          d = {
            x: f.offsetX + 2 * M.left - (A.left + C.left),
            y: f.offsetY + 2 * M.top - (A.top + C.top)
          };
        } else
          d = {
            x: (i = f.offsetX) !== null && i !== void 0 ? i : f.clientX,
            y: (s = f.offsetY) !== null && s !== void 0 ? s : f.clientY
          };
      } else
        f.target === c.canvas.element && (d = {
          x: (o = f.offsetX) !== null && o !== void 0 ? o : f.clientX,
          y: (r = f.offsetY) !== null && r !== void 0 ? r : f.clientY
        });
    } else {
      this.canPush = e.type !== "touchmove";
      const f = e, v = f.touches[f.touches.length - 1], m = h == null ? void 0 : h.getBoundingClientRect();
      d = {
        x: v.clientX - ((a = m == null ? void 0 : m.left) !== null && a !== void 0 ? a : 0),
        y: v.clientY - ((l = m == null ? void 0 : m.top) !== null && l !== void 0 ? l : 0)
      };
    }
    const p = c.retina.pixelRatio;
    d && (d.x *= p, d.y *= p), c.interactivity.mouse.position = d, c.interactivity.status = ct;
  }
}
class mi {
  constructor(e) {
    this.container = e;
  }
  async nextFrame(e) {
    var t;
    try {
      const i = this.container;
      if (i.lastFrameTime !== void 0 && e < i.lastFrameTime + 1e3 / i.fpsLimit) {
        i.draw(!1);
        return;
      }
      (t = i.lastFrameTime) !== null && t !== void 0 || (i.lastFrameTime = e);
      const s = e - i.lastFrameTime, o = {
        value: s,
        factor: 60 * s / 1e3
      };
      if (i.lifeTime += o.value, i.lastFrameTime = e, s > 1e3) {
        i.draw(!1);
        return;
      }
      if (await i.particles.draw(o), i.duration > 0 && i.lifeTime > i.duration) {
        i.destroy();
        return;
      }
      i.getAnimationStatus() && i.draw(!1);
    } catch (i) {
      console.error("tsParticles error in animation loop", i);
    }
  }
}
class H {
  constructor() {
    this.value = "";
  }
  static create(e, t) {
    const i = new H();
    return i.load(e), t !== void 0 && (typeof t == "string" || t instanceof Array ? i.load({ value: t }) : i.load(t)), i;
  }
  load(e) {
    (e == null ? void 0 : e.value) !== void 0 && (this.value = e.value);
  }
}
class vi {
  constructor() {
    this.color = new H(), this.color.value = "", this.image = "", this.position = "", this.repeat = "", this.size = "", this.opacity = 1;
  }
  load(e) {
    !e || (e.color !== void 0 && (this.color = H.create(this.color, e.color)), e.image !== void 0 && (this.image = e.image), e.position !== void 0 && (this.position = e.position), e.repeat !== void 0 && (this.repeat = e.repeat), e.size !== void 0 && (this.size = e.size), e.opacity !== void 0 && (this.opacity = e.opacity));
  }
}
class gi {
  constructor() {
    this.color = new H(), this.color.value = "#fff", this.opacity = 1;
  }
  load(e) {
    !e || (e.color !== void 0 && (this.color = H.create(this.color, e.color)), e.opacity !== void 0 && (this.opacity = e.opacity));
  }
}
class yi {
  constructor() {
    this.composite = "destination-out", this.cover = new gi(), this.enable = !1;
  }
  load(e) {
    if (!!e) {
      if (e.composite !== void 0 && (this.composite = e.composite), e.cover !== void 0) {
        const t = e.cover, i = typeof e.cover == "string" ? { color: e.cover } : e.cover;
        this.cover.load(t.color !== void 0 ? t : { color: i });
      }
      e.enable !== void 0 && (this.enable = e.enable);
    }
  }
}
class wi {
  constructor() {
    this.enable = !0, this.zIndex = 0;
  }
  load(e) {
    !e || (e.enable !== void 0 && (this.enable = e.enable), e.zIndex !== void 0 && (this.zIndex = e.zIndex));
  }
}
class bi {
  constructor() {
    this.enable = !1, this.mode = [];
  }
  load(e) {
    !e || (e.enable !== void 0 && (this.enable = e.enable), e.mode !== void 0 && (this.mode = e.mode));
  }
}
class $e {
  constructor() {
    this.selectors = [], this.enable = !1, this.mode = [], this.type = "circle";
  }
  get el() {
    return this.elementId;
  }
  set el(e) {
    this.elementId = e;
  }
  get elementId() {
    return this.ids;
  }
  set elementId(e) {
    this.ids = e;
  }
  get ids() {
    return this.selectors instanceof Array ? this.selectors.map((e) => e.replace("#", "")) : this.selectors.replace("#", "");
  }
  set ids(e) {
    this.selectors = e instanceof Array ? e.map((t) => `#${t}`) : `#${e}`;
  }
  load(e) {
    var t, i;
    if (!e)
      return;
    const s = (i = (t = e.ids) !== null && t !== void 0 ? t : e.elementId) !== null && i !== void 0 ? i : e.el;
    s !== void 0 && (this.ids = s), e.selectors !== void 0 && (this.selectors = e.selectors), e.enable !== void 0 && (this.enable = e.enable), e.mode !== void 0 && (this.mode = e.mode), e.type !== void 0 && (this.type = e.type);
  }
}
class _i {
  constructor() {
    this.enable = !1, this.force = 2, this.smooth = 10;
  }
  load(e) {
    !e || (e.enable !== void 0 && (this.enable = e.enable), e.force !== void 0 && (this.force = e.force), e.smooth !== void 0 && (this.smooth = e.smooth));
  }
}
class Pi {
  constructor() {
    this.enable = !1, this.mode = [], this.parallax = new _i();
  }
  load(e) {
    !e || (e.enable !== void 0 && (this.enable = e.enable), e.mode !== void 0 && (this.mode = e.mode), this.parallax.load(e.parallax));
  }
}
class xi {
  constructor() {
    this.onClick = new bi(), this.onDiv = new $e(), this.onHover = new Pi(), this.resize = !0;
  }
  get onclick() {
    return this.onClick;
  }
  set onclick(e) {
    this.onClick = e;
  }
  get ondiv() {
    return this.onDiv;
  }
  set ondiv(e) {
    this.onDiv = e;
  }
  get onhover() {
    return this.onHover;
  }
  set onhover(e) {
    this.onHover = e;
  }
  load(e) {
    var t, i, s;
    if (!e)
      return;
    this.onClick.load((t = e.onClick) !== null && t !== void 0 ? t : e.onclick);
    const o = (i = e.onDiv) !== null && i !== void 0 ? i : e.ondiv;
    o !== void 0 && (o instanceof Array ? this.onDiv = o.map((r) => {
      const a = new $e();
      return a.load(r), a;
    }) : (this.onDiv = new $e(), this.onDiv.load(o))), this.onHover.load((s = e.onHover) !== null && s !== void 0 ? s : e.onhover), e.resize !== void 0 && (this.resize = e.resize);
  }
}
class zi {
  constructor() {
    this.factor = 3, this.radius = 200;
  }
  load(e) {
    !e || (e.factor !== void 0 && (this.factor = e.factor), e.radius !== void 0 && (this.radius = e.radius));
  }
}
var dt = globalThis && globalThis.__classPrivateFieldSet || function(n, e, t, i, s) {
  if (i === "m")
    throw new TypeError("Private method is not writable");
  if (i === "a" && !s)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof e == "function" ? n !== e || !s : !e.has(n))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return i === "a" ? s.call(n, t) : s ? s.value = t : e.set(n, t), t;
}, qe = globalThis && globalThis.__classPrivateFieldGet || function(n, e, t, i) {
  if (t === "a" && !i)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof e == "function" ? n !== e || !i : !e.has(n))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return t === "m" ? i : t === "a" ? i.call(n) : i ? i.value : e.get(n);
}, ge, ke;
class Mi {
  constructor(e, t) {
    ge.set(this, void 0), ke.set(this, void 0), dt(this, ke, e, "f"), dt(this, ge, t, "f"), this.slow = new zi();
  }
  load(e) {
    if (!!e && (this.slow.load(e.slow), qe(this, ge, "f"))) {
      const t = qe(this, ke, "f").plugins.interactors.get(qe(this, ge, "f"));
      if (t)
        for (const i of t)
          i.loadModeOptions && i.loadModeOptions(this, e);
    }
  }
}
ge = /* @__PURE__ */ new WeakMap(), ke = /* @__PURE__ */ new WeakMap();
var ft = globalThis && globalThis.__classPrivateFieldSet || function(n, e, t, i, s) {
  if (i === "m")
    throw new TypeError("Private method is not writable");
  if (i === "a" && !s)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof e == "function" ? n !== e || !s : !e.has(n))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return i === "a" ? s.call(n, t) : s ? s.value = t : e.set(n, t), t;
}, Ye, Je;
class Mt {
  constructor(e, t) {
    Ye.set(this, void 0), Je.set(this, void 0), ft(this, Je, e, "f"), ft(this, Ye, t, "f"), this.detectsOn = "window", this.events = new xi(), this.modes = new Mi(e, t);
  }
  get detect_on() {
    return this.detectsOn;
  }
  set detect_on(e) {
    this.detectsOn = e;
  }
  load(e) {
    var t;
    if (!e)
      return;
    const i = (t = e.detectsOn) !== null && t !== void 0 ? t : e.detect_on;
    i !== void 0 && (this.detectsOn = i), this.events.load(e.events), this.modes.load(e.modes);
  }
}
Ye = /* @__PURE__ */ new WeakMap(), Je = /* @__PURE__ */ new WeakMap();
class Ti {
  load(e) {
    var t, i;
    !e || (e.position !== void 0 && (this.position = {
      x: (t = e.position.x) !== null && t !== void 0 ? t : 50,
      y: (i = e.position.y) !== null && i !== void 0 ? i : 50
    }), e.options !== void 0 && (this.options = z({}, e.options)));
  }
}
class Ci {
  constructor() {
    this.factor = 4, this.value = !0;
  }
  load(e) {
    !e || (e.factor !== void 0 && (this.factor = e.factor), e.value !== void 0 && (this.value = e.value));
  }
}
class Si {
  constructor() {
    this.disable = !1, this.reduce = new Ci();
  }
  load(e) {
    !e || (e.disable !== void 0 && (this.disable = e.disable), this.reduce.load(e.reduce));
  }
}
class Ei {
  constructor() {
    this.maxWidth = 1 / 0, this.options = {}, this.mode = "canvas";
  }
  load(e) {
    !e || (e.maxWidth !== void 0 && (this.maxWidth = e.maxWidth), e.mode !== void 0 && (e.mode === "screen" ? this.mode = "screen" : this.mode = "canvas"), e.options !== void 0 && (this.options = z({}, e.options)));
  }
}
class ki {
  constructor() {
    this.auto = !1, this.mode = "any", this.value = !1;
  }
  load(e) {
    !e || (e.auto !== void 0 && (this.auto = e.auto), e.mode !== void 0 && (this.mode = e.mode), e.value !== void 0 && (this.value = e.value));
  }
}
class Oi {
  constructor() {
    this.name = "", this.default = new ki();
  }
  load(e) {
    !e || (e.name !== void 0 && (this.name = e.name), this.default.load(e.default), e.options !== void 0 && (this.options = z({}, e.options)));
  }
}
class Ge {
  constructor() {
    this.count = 0, this.enable = !1, this.offset = 0, this.speed = 1, this.decay = 0, this.sync = !0;
  }
  load(e) {
    !e || (e.count !== void 0 && (this.count = y(e.count)), e.enable !== void 0 && (this.enable = e.enable), e.offset !== void 0 && (this.offset = y(e.offset)), e.speed !== void 0 && (this.speed = y(e.speed)), e.decay !== void 0 && (this.decay = y(e.decay)), e.sync !== void 0 && (this.sync = e.sync));
  }
}
class Ri {
  constructor() {
    this.h = new Ge(), this.s = new Ge(), this.l = new Ge();
  }
  load(e) {
    !e || (this.h.load(e.h), this.s.load(e.s), this.l.load(e.l));
  }
}
class Ce extends H {
  constructor() {
    super(), this.animation = new Ri();
  }
  static create(e, t) {
    const i = new Ce();
    return i.load(e), t !== void 0 && (typeof t == "string" || t instanceof Array ? i.load({ value: t }) : i.load(t)), i;
  }
  load(e) {
    if (super.load(e), !e)
      return;
    const t = e.animation;
    t !== void 0 && (t.enable !== void 0 ? this.animation.h.load(t) : this.animation.load(e.animation));
  }
}
class Fi {
  constructor() {
    this.enable = !0, this.retries = 0;
  }
  load(e) {
    !e || (e.enable !== void 0 && (this.enable = e.enable), e.retries !== void 0 && (this.retries = e.retries));
  }
}
class Ii {
  constructor() {
    this.enable = !1, this.minimumValue = 0;
  }
  load(e) {
    !e || (e.enable !== void 0 && (this.enable = e.enable), e.minimumValue !== void 0 && (this.minimumValue = e.minimumValue));
  }
}
class Q {
  constructor() {
    this.random = new Ii(), this.value = 0;
  }
  load(e) {
    !e || (typeof e.random == "boolean" ? this.random.enable = e.random : this.random.load(e.random), e.value !== void 0 && (this.value = y(e.value, this.random.enable ? this.random.minimumValue : void 0)));
  }
}
class pt extends Q {
  constructor() {
    super(), this.random.minimumValue = 0.1, this.value = 1;
  }
}
class Tt {
  constructor() {
    this.horizontal = new pt(), this.vertical = new pt();
  }
  load(e) {
    !e || (this.horizontal.load(e.horizontal), this.vertical.load(e.vertical));
  }
}
class Ai {
  constructor() {
    this.bounce = new Tt(), this.enable = !1, this.mode = "bounce", this.overlap = new Fi();
  }
  load(e) {
    !e || (this.bounce.load(e.bounce), e.enable !== void 0 && (this.enable = e.enable), e.mode !== void 0 && (this.mode = e.mode), this.overlap.load(e.overlap));
  }
}
class Di extends Q {
  constructor() {
    super(), this.value = 3;
  }
}
class Li extends Q {
  constructor() {
    super(), this.value = { min: 4, max: 9 };
  }
}
class Wi {
  constructor() {
    this.count = 1, this.factor = new Di(), this.rate = new Li(), this.sizeOffset = !0;
  }
  load(e) {
    !e || (e.count !== void 0 && (this.count = e.count), this.factor.load(e.factor), this.rate.load(e.rate), e.particles !== void 0 && (e.particles instanceof Array ? this.particles = e.particles.map((t) => z({}, t)) : this.particles = z({}, e.particles)), e.sizeOffset !== void 0 && (this.sizeOffset = e.sizeOffset));
  }
}
class Hi {
  constructor() {
    this.mode = "none", this.split = new Wi();
  }
  load(e) {
    !e || (e.mode !== void 0 && (this.mode = e.mode), this.split.load(e.split));
  }
}
class Vi {
  constructor() {
    this.offset = 0, this.value = 90;
  }
  load(e) {
    !e || (e.offset !== void 0 && (this.offset = y(e.offset)), e.value !== void 0 && (this.value = y(e.value)));
  }
}
class $i {
  constructor() {
    this.distance = 200, this.enable = !1, this.rotate = {
      x: 3e3,
      y: 3e3
    };
  }
  get rotateX() {
    return this.rotate.x;
  }
  set rotateX(e) {
    this.rotate.x = e;
  }
  get rotateY() {
    return this.rotate.y;
  }
  set rotateY(e) {
    this.rotate.y = e;
  }
  load(e) {
    var t, i, s, o;
    if (!e)
      return;
    e.distance !== void 0 && (this.distance = y(e.distance)), e.enable !== void 0 && (this.enable = e.enable);
    const r = (i = (t = e.rotate) === null || t === void 0 ? void 0 : t.x) !== null && i !== void 0 ? i : e.rotateX;
    r !== void 0 && (this.rotate.x = r);
    const a = (o = (s = e.rotate) === null || s === void 0 ? void 0 : s.y) !== null && o !== void 0 ? o : e.rotateY;
    a !== void 0 && (this.rotate.y = a);
  }
}
class qi {
  constructor() {
    this.acceleration = 9.81, this.enable = !1, this.inverse = !1, this.maxSpeed = 50;
  }
  load(e) {
    !e || (e.acceleration !== void 0 && (this.acceleration = y(e.acceleration)), e.enable !== void 0 && (this.enable = e.enable), e.inverse !== void 0 && (this.inverse = e.inverse), e.maxSpeed !== void 0 && (this.maxSpeed = y(e.maxSpeed)));
  }
}
class Gi extends Q {
  constructor() {
    super();
  }
}
class ji {
  constructor() {
    this.clamp = !0, this.delay = new Gi(), this.enable = !1, this.options = {};
  }
  load(e) {
    !e || (e.clamp !== void 0 && (this.clamp = e.clamp), this.delay.load(e.delay), e.enable !== void 0 && (this.enable = e.enable), this.generator = e.generator, e.options && (this.options = z(this.options, e.options)));
  }
}
class Bi {
  constructor() {
    this.enable = !1, this.length = 10, this.fillColor = new H(), this.fillColor.value = "#000000";
  }
  load(e) {
    !e || (e.enable !== void 0 && (this.enable = e.enable), this.fillColor = H.create(this.fillColor, e.fillColor), e.length !== void 0 && (this.length = e.length));
  }
}
class Ni {
  constructor() {
    this.default = "out";
  }
  load(e) {
    var t, i, s, o;
    !e || (e.default !== void 0 && (this.default = e.default), this.bottom = (t = e.bottom) !== null && t !== void 0 ? t : e.default, this.left = (i = e.left) !== null && i !== void 0 ? i : e.default, this.right = (s = e.right) !== null && s !== void 0 ? s : e.default, this.top = (o = e.top) !== null && o !== void 0 ? o : e.default);
  }
}
class Ui {
  constructor() {
    this.acceleration = 0, this.enable = !1;
  }
  load(e) {
    !e || (e.acceleration !== void 0 && (this.acceleration = y(e.acceleration)), e.enable !== void 0 && (this.enable = e.enable), this.position = e.position ? z({}, e.position) : void 0);
  }
}
class Xi {
  constructor() {
    this.angle = new Vi(), this.attract = new $i(), this.center = {
      x: 50,
      y: 50,
      radius: 0
    }, this.decay = 0, this.distance = {}, this.direction = "none", this.drift = 0, this.enable = !1, this.gravity = new qi(), this.path = new ji(), this.outModes = new Ni(), this.random = !1, this.size = !1, this.speed = 2, this.spin = new Ui(), this.straight = !1, this.trail = new Bi(), this.vibrate = !1, this.warp = !1;
  }
  get bounce() {
    return this.collisions;
  }
  set bounce(e) {
    this.collisions = e;
  }
  get collisions() {
    return !1;
  }
  set collisions(e) {
  }
  get noise() {
    return this.path;
  }
  set noise(e) {
    this.path = e;
  }
  get outMode() {
    return this.outModes.default;
  }
  set outMode(e) {
    this.outModes.default = e;
  }
  get out_mode() {
    return this.outMode;
  }
  set out_mode(e) {
    this.outMode = e;
  }
  load(e) {
    var t, i, s;
    if (!e)
      return;
    e.angle !== void 0 && (typeof e.angle == "number" ? this.angle.value = e.angle : this.angle.load(e.angle)), this.attract.load(e.attract), this.center = z(this.center, e.center), e.decay !== void 0 && (this.decay = e.decay), e.direction !== void 0 && (this.direction = e.direction), e.distance !== void 0 && (this.distance = typeof e.distance == "number" ? {
      horizontal: e.distance,
      vertical: e.distance
    } : z({}, e.distance)), e.drift !== void 0 && (this.drift = y(e.drift)), e.enable !== void 0 && (this.enable = e.enable), this.gravity.load(e.gravity);
    const o = (t = e.outMode) !== null && t !== void 0 ? t : e.out_mode;
    (e.outModes !== void 0 || o !== void 0) && (typeof e.outModes == "string" || e.outModes === void 0 && o !== void 0 ? this.outModes.load({
      default: (i = e.outModes) !== null && i !== void 0 ? i : o
    }) : this.outModes.load(e.outModes)), this.path.load((s = e.path) !== null && s !== void 0 ? s : e.noise), e.random !== void 0 && (this.random = e.random), e.size !== void 0 && (this.size = e.size), e.speed !== void 0 && (this.speed = y(e.speed)), this.spin.load(e.spin), e.straight !== void 0 && (this.straight = e.straight), this.trail.load(e.trail), e.vibrate !== void 0 && (this.vibrate = e.vibrate), e.warp !== void 0 && (this.warp = e.warp);
  }
}
class Ct {
  constructor() {
    this.count = 0, this.enable = !1, this.speed = 1, this.decay = 0, this.sync = !1;
  }
  load(e) {
    !e || (e.count !== void 0 && (this.count = y(e.count)), e.enable !== void 0 && (this.enable = e.enable), e.speed !== void 0 && (this.speed = y(e.speed)), e.decay !== void 0 && (this.decay = y(e.decay)), e.sync !== void 0 && (this.sync = e.sync));
  }
}
class Yi extends Ct {
  constructor() {
    super(), this.destroy = "none", this.enable = !1, this.speed = 2, this.startValue = "random", this.sync = !1;
  }
  get opacity_min() {
    return this.minimumValue;
  }
  set opacity_min(e) {
    this.minimumValue = e;
  }
  load(e) {
    var t;
    !e || (super.load(e), e.destroy !== void 0 && (this.destroy = e.destroy), e.enable !== void 0 && (this.enable = e.enable), this.minimumValue = (t = e.minimumValue) !== null && t !== void 0 ? t : e.opacity_min, e.speed !== void 0 && (this.speed = e.speed), e.startValue !== void 0 && (this.startValue = e.startValue), e.sync !== void 0 && (this.sync = e.sync));
  }
}
class Ji extends Q {
  constructor() {
    super(), this.animation = new Yi(), this.random.minimumValue = 0.1, this.value = 1;
  }
  get anim() {
    return this.animation;
  }
  set anim(e) {
    this.animation = e;
  }
  load(e) {
    var t;
    if (!e)
      return;
    super.load(e);
    const i = (t = e.animation) !== null && t !== void 0 ? t : e.anim;
    i !== void 0 && (this.animation.load(i), this.value = y(this.value, this.animation.enable ? this.animation.minimumValue : void 0));
  }
}
class Zi {
  constructor() {
    this.enable = !1, this.area = 800, this.factor = 1e3;
  }
  get value_area() {
    return this.area;
  }
  set value_area(e) {
    this.area = e;
  }
  load(e) {
    var t;
    if (!e)
      return;
    e.enable !== void 0 && (this.enable = e.enable);
    const i = (t = e.area) !== null && t !== void 0 ? t : e.value_area;
    i !== void 0 && (this.area = i), e.factor !== void 0 && (this.factor = e.factor);
  }
}
class Qi {
  constructor() {
    this.density = new Zi(), this.limit = 0, this.value = 100;
  }
  get max() {
    return this.limit;
  }
  set max(e) {
    this.limit = e;
  }
  load(e) {
    var t;
    if (!e)
      return;
    this.density.load(e.density);
    const i = (t = e.limit) !== null && t !== void 0 ? t : e.max;
    i !== void 0 && (this.limit = i), e.value !== void 0 && (this.value = e.value);
  }
}
class Ki {
  constructor() {
    this.enable = !1, this.speed = 0, this.decay = 0, this.sync = !1;
  }
  load(e) {
    !e || (e.enable !== void 0 && (this.enable = e.enable), e.speed !== void 0 && (this.speed = y(e.speed)), e.decay !== void 0 && (this.decay = y(e.decay)), e.sync !== void 0 && (this.sync = e.sync));
  }
}
class es extends Q {
  constructor() {
    super(), this.animation = new Ki(), this.direction = "clockwise", this.path = !1, this.value = 0;
  }
  load(e) {
    !e || (super.load(e), e.direction !== void 0 && (this.direction = e.direction), this.animation.load(e.animation), e.path !== void 0 && (this.path = e.path));
  }
}
class ts {
  constructor() {
    this.blur = 0, this.color = new H(), this.enable = !1, this.offset = {
      x: 0,
      y: 0
    }, this.color.value = "#000";
  }
  load(e) {
    !e || (e.blur !== void 0 && (this.blur = e.blur), this.color = H.create(this.color, e.color), e.enable !== void 0 && (this.enable = e.enable), e.offset !== void 0 && (e.offset.x !== void 0 && (this.offset.x = e.offset.x), e.offset.y !== void 0 && (this.offset.y = e.offset.y)));
  }
}
class St {
  constructor() {
    this.options = {}, this.type = "circle";
  }
  get character() {
    var e;
    return (e = this.options.character) !== null && e !== void 0 ? e : this.options.char;
  }
  set character(e) {
    this.options.character = e, this.options.char = e;
  }
  get custom() {
    return this.options;
  }
  set custom(e) {
    this.options = e;
  }
  get image() {
    var e;
    return (e = this.options.image) !== null && e !== void 0 ? e : this.options.images;
  }
  set image(e) {
    this.options.image = e, this.options.images = e;
  }
  get images() {
    return this.image;
  }
  set images(e) {
    this.image = e;
  }
  get polygon() {
    var e;
    return (e = this.options.polygon) !== null && e !== void 0 ? e : this.options.star;
  }
  set polygon(e) {
    this.options.polygon = e, this.options.star = e;
  }
  get stroke() {
    return [];
  }
  set stroke(e) {
  }
  load(e) {
    var t, i, s;
    if (!e)
      return;
    const o = (t = e.options) !== null && t !== void 0 ? t : e.custom;
    if (o !== void 0)
      for (const r in o) {
        const a = o[r];
        a && (this.options[r] = z((i = this.options[r]) !== null && i !== void 0 ? i : {}, a));
      }
    this.loadShape(e.character, "character", "char", !0), this.loadShape(e.polygon, "polygon", "star", !1), this.loadShape((s = e.image) !== null && s !== void 0 ? s : e.images, "image", "images", !0), e.type !== void 0 && (this.type = e.type);
  }
  loadShape(e, t, i, s) {
    var o, r;
    if (!e)
      return;
    const a = e instanceof Array ? [] : {}, l = e instanceof Array != this.options[t] instanceof Array, c = e instanceof Array != this.options[i] instanceof Array;
    l && (this.options[t] = a), c && s && (this.options[i] = a), this.options[t] = z((o = this.options[t]) !== null && o !== void 0 ? o : a, e), (!this.options[i] || s) && (this.options[i] = z((r = this.options[i]) !== null && r !== void 0 ? r : a, e));
  }
}
class is extends Ct {
  constructor() {
    super(), this.destroy = "none", this.enable = !1, this.speed = 5, this.startValue = "random", this.sync = !1;
  }
  get size_min() {
    return this.minimumValue;
  }
  set size_min(e) {
    this.minimumValue = e;
  }
  load(e) {
    var t;
    super.load(e), e && (e.destroy !== void 0 && (this.destroy = e.destroy), e.enable !== void 0 && (this.enable = e.enable), this.minimumValue = (t = e.minimumValue) !== null && t !== void 0 ? t : e.size_min, e.speed !== void 0 && (this.speed = e.speed), e.startValue !== void 0 && (this.startValue = e.startValue), e.sync !== void 0 && (this.sync = e.sync));
  }
}
class ss extends Q {
  constructor() {
    super(), this.animation = new is(), this.random.minimumValue = 1, this.value = 3;
  }
  get anim() {
    return this.animation;
  }
  set anim(e) {
    this.animation = e;
  }
  load(e) {
    var t;
    if (super.load(e), !e)
      return;
    const i = (t = e.animation) !== null && t !== void 0 ? t : e.anim;
    i !== void 0 && (this.animation.load(i), this.value = y(this.value, this.animation.enable ? this.animation.minimumValue : void 0));
  }
}
class je {
  constructor() {
    this.width = 0;
  }
  load(e) {
    !e || (e.color !== void 0 && (this.color = Ce.create(this.color, e.color)), e.width !== void 0 && (this.width = e.width), e.opacity !== void 0 && (this.opacity = e.opacity));
  }
}
class ns extends Q {
  constructor() {
    super(), this.opacityRate = 1, this.sizeRate = 1, this.velocityRate = 1;
  }
  load(e) {
    super.load(e), e && (e.opacityRate !== void 0 && (this.opacityRate = e.opacityRate), e.sizeRate !== void 0 && (this.sizeRate = e.sizeRate), e.velocityRate !== void 0 && (this.velocityRate = e.velocityRate));
  }
}
var mt = globalThis && globalThis.__classPrivateFieldSet || function(n, e, t, i, s) {
  if (i === "m")
    throw new TypeError("Private method is not writable");
  if (i === "a" && !s)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof e == "function" ? n !== e || !s : !e.has(n))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return i === "a" ? s.call(n, t) : s ? s.value = t : e.set(n, t), t;
}, pe = globalThis && globalThis.__classPrivateFieldGet || function(n, e, t, i) {
  if (t === "a" && !i)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof e == "function" ? n !== e || !i : !e.has(n))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return t === "m" ? i : t === "a" ? i.call(n) : i ? i.value : e.get(n);
}, le, ye;
class os {
  constructor(e, t) {
    le.set(this, void 0), ye.set(this, void 0), mt(this, ye, e, "f"), mt(this, le, t, "f"), this.bounce = new Tt(), this.collisions = new Ai(), this.color = new Ce(), this.color.value = "#fff", this.destroy = new Hi(), this.groups = {}, this.move = new Xi(), this.number = new Qi(), this.opacity = new Ji(), this.reduceDuplicates = !1, this.rotate = new es(), this.shadow = new ts(), this.shape = new St(), this.size = new ss(), this.stroke = new je(), this.zIndex = new ns();
  }
  load(e) {
    var t, i, s, o, r, a;
    if (!e)
      return;
    if (this.bounce.load(e.bounce), this.color.load(Ce.create(this.color, e.color)), this.destroy.load(e.destroy), e.groups !== void 0)
      for (const u in e.groups) {
        const d = e.groups[u];
        d !== void 0 && (this.groups[u] = z((t = this.groups[u]) !== null && t !== void 0 ? t : {}, d));
      }
    this.move.load(e.move), this.number.load(e.number), this.opacity.load(e.opacity), e.reduceDuplicates !== void 0 && (this.reduceDuplicates = e.reduceDuplicates), this.rotate.load(e.rotate), this.shape.load(e.shape), this.size.load(e.size), this.shadow.load(e.shadow), this.zIndex.load(e.zIndex);
    const l = (s = (i = e.move) === null || i === void 0 ? void 0 : i.collisions) !== null && s !== void 0 ? s : (o = e.move) === null || o === void 0 ? void 0 : o.bounce;
    l !== void 0 && (this.collisions.enable = l), this.collisions.load(e.collisions), e.interactivity !== void 0 && (this.interactivity = z({}, e.interactivity));
    const c = (r = e.stroke) !== null && r !== void 0 ? r : (a = e.shape) === null || a === void 0 ? void 0 : a.stroke;
    if (c && (c instanceof Array ? this.stroke = c.map((u) => {
      const d = new je();
      return d.load(u), d;
    }) : (this.stroke instanceof Array && (this.stroke = new je()), this.stroke.load(c))), pe(this, le, "f")) {
      const u = pe(this, ye, "f").plugins.updaters.get(pe(this, le, "f"));
      if (u)
        for (const h of u)
          h.loadOptions && h.loadOptions(this, e);
      const d = pe(this, ye, "f").plugins.interactors.get(pe(this, le, "f"));
      if (d)
        for (const h of d)
          h.loadParticlesOptions && h.loadParticlesOptions(this, e);
    }
  }
}
le = /* @__PURE__ */ new WeakMap(), ye = /* @__PURE__ */ new WeakMap();
function Et(n, ...e) {
  for (const t of e)
    n.load(t);
}
function et(n, e, ...t) {
  const i = new os(n, e);
  return Et(i, ...t), i;
}
var vt = globalThis && globalThis.__classPrivateFieldSet || function(n, e, t, i, s) {
  if (i === "m")
    throw new TypeError("Private method is not writable");
  if (i === "a" && !s)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof e == "function" ? n !== e || !s : !e.has(n))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return i === "a" ? s.call(n, t) : s ? s.value = t : e.set(n, t), t;
}, q = globalThis && globalThis.__classPrivateFieldGet || function(n, e, t, i) {
  if (t === "a" && !i)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof e == "function" ? n !== e || !i : !e.has(n))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return t === "m" ? i : t === "a" ? i.call(n) : i ? i.value : e.get(n);
}, we, be, ie, Oe;
class rs {
  constructor(e, t) {
    we.add(this), be.set(this, void 0), ie.set(this, void 0), vt(this, ie, e, "f"), vt(this, be, t, "f"), this.autoPlay = !0, this.background = new vi(), this.backgroundMask = new yi(), this.fullScreen = new wi(), this.detectRetina = !0, this.duration = 0, this.fpsLimit = 120, this.interactivity = new Mt(e, t), this.manualParticles = [], this.motion = new Si(), this.particles = et(q(this, ie, "f"), q(this, be, "f")), this.pauseOnBlur = !0, this.pauseOnOutsideViewport = !0, this.responsive = [], this.style = {}, this.themes = [], this.zLayers = 100;
  }
  get backgroundMode() {
    return this.fullScreen;
  }
  set backgroundMode(e) {
    this.fullScreen.load(e);
  }
  get fps_limit() {
    return this.fpsLimit;
  }
  set fps_limit(e) {
    this.fpsLimit = e;
  }
  get retina_detect() {
    return this.detectRetina;
  }
  set retina_detect(e) {
    this.detectRetina = e;
  }
  load(e) {
    var t, i, s, o, r;
    if (!e)
      return;
    if (e.preset !== void 0)
      if (e.preset instanceof Array)
        for (const d of e.preset)
          this.importPreset(d);
      else
        this.importPreset(e.preset);
    e.autoPlay !== void 0 && (this.autoPlay = e.autoPlay);
    const a = (t = e.detectRetina) !== null && t !== void 0 ? t : e.retina_detect;
    a !== void 0 && (this.detectRetina = a), e.duration !== void 0 && (this.duration = e.duration);
    const l = (i = e.fpsLimit) !== null && i !== void 0 ? i : e.fps_limit;
    l !== void 0 && (this.fpsLimit = l), e.pauseOnBlur !== void 0 && (this.pauseOnBlur = e.pauseOnBlur), e.pauseOnOutsideViewport !== void 0 && (this.pauseOnOutsideViewport = e.pauseOnOutsideViewport), e.zLayers !== void 0 && (this.zLayers = e.zLayers), this.background.load(e.background);
    const c = (s = e.fullScreen) !== null && s !== void 0 ? s : e.backgroundMode;
    typeof c == "boolean" ? this.fullScreen.enable = c : this.fullScreen.load(c), this.backgroundMask.load(e.backgroundMask), this.interactivity.load(e.interactivity), e.manualParticles !== void 0 && (this.manualParticles = e.manualParticles.map((d) => {
      const h = new Ti();
      return h.load(d), h;
    })), this.motion.load(e.motion), this.particles.load(e.particles), this.style = z(this.style, e.style), q(this, ie, "f").plugins.loadOptions(this, e);
    const u = q(this, ie, "f").plugins.interactors.get(q(this, be, "f"));
    if (u)
      for (const d of u)
        d.loadOptions && d.loadOptions(this, e);
    if (e.responsive !== void 0)
      for (const d of e.responsive) {
        const h = new Ei();
        h.load(d), this.responsive.push(h);
      }
    if (this.responsive.sort((d, h) => d.maxWidth - h.maxWidth), e.themes !== void 0)
      for (const d of e.themes) {
        const h = new Oi();
        h.load(d), this.themes.push(h);
      }
    this.defaultDarkTheme = (o = q(this, we, "m", Oe).call(this, "dark")) === null || o === void 0 ? void 0 : o.name, this.defaultLightTheme = (r = q(this, we, "m", Oe).call(this, "light")) === null || r === void 0 ? void 0 : r.name;
  }
  setResponsive(e, t, i) {
    this.load(i);
    const s = this.responsive.find((o) => o.mode === "screen" && screen ? o.maxWidth > screen.availWidth : o.maxWidth * t > e);
    return this.load(s == null ? void 0 : s.options), s == null ? void 0 : s.maxWidth;
  }
  setTheme(e) {
    if (e) {
      const t = this.themes.find((i) => i.name === e);
      t && this.load(t.options);
    } else {
      const t = typeof matchMedia < "u" && matchMedia("(prefers-color-scheme: dark)"), i = t && t.matches, s = q(this, we, "m", Oe).call(this, i ? "dark" : "light");
      s && this.load(s.options);
    }
  }
  importPreset(e) {
    this.load(q(this, ie, "f").plugins.getPreset(e));
  }
}
be = /* @__PURE__ */ new WeakMap(), ie = /* @__PURE__ */ new WeakMap(), we = /* @__PURE__ */ new WeakSet(), Oe = function(e) {
  var t;
  return (t = this.themes.find((i) => i.default.value && i.default.mode === e)) !== null && t !== void 0 ? t : this.themes.find((i) => i.default.value && i.default.mode === "any");
};
var gt = globalThis && globalThis.__classPrivateFieldSet || function(n, e, t, i, s) {
  if (i === "m")
    throw new TypeError("Private method is not writable");
  if (i === "a" && !s)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof e == "function" ? n !== e || !s : !e.has(n))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return i === "a" ? s.call(n, t) : s ? s.value = t : e.set(n, t), t;
}, yt = globalThis && globalThis.__classPrivateFieldGet || function(n, e, t, i) {
  if (t === "a" && !i)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof e == "function" ? n !== e || !i : !e.has(n))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return t === "m" ? i : t === "a" ? i.call(n) : i ? i.value : e.get(n);
}, Re, Fe;
class as {
  constructor(e, t) {
    this.container = t, Re.set(this, void 0), Fe.set(this, void 0), gt(this, Re, e, "f"), gt(this, Fe, yt(this, Re, "f").plugins.getInteractors(this.container, !0), "f"), this.externalInteractors = [], this.particleInteractors = [];
  }
  async externalInteract(e) {
    for (const t of this.externalInteractors)
      t.isEnabled() && await t.interact(e);
  }
  handleClickMode(e) {
    for (const t of this.externalInteractors)
      t.handleClickMode && t.handleClickMode(e);
  }
  init() {
    this.externalInteractors = [], this.particleInteractors = [];
    for (const e of yt(this, Fe, "f")) {
      switch (e.type) {
        case 0:
          this.externalInteractors.push(e);
          break;
        case 1:
          this.particleInteractors.push(e);
          break;
      }
      e.init();
    }
  }
  async particlesInteract(e, t) {
    for (const i of this.externalInteractors)
      i.clear(e);
    for (const i of this.particleInteractors)
      i.isEnabled(e) && await i.interact(e, t);
  }
  async reset(e) {
    for (const t of this.externalInteractors)
      t.isEnabled() && await t.reset(e);
    for (const t of this.particleInteractors)
      t.isEnabled(e) && await t.reset(e);
  }
}
Re = /* @__PURE__ */ new WeakMap(), Fe = /* @__PURE__ */ new WeakMap();
class S extends R {
  constructor(e, t, i) {
    if (super(e, t), typeof e != "number" && e)
      this.z = e.z;
    else if (i !== void 0)
      this.z = i;
    else
      throw new Error("tsParticles - Vector not initialized correctly");
  }
  static get origin() {
    return S.create(0, 0, 0);
  }
  static clone(e) {
    return S.create(e.x, e.y, e.z);
  }
  static create(e, t, i) {
    return new S(e, t, i);
  }
  add(e) {
    return e instanceof S ? S.create(this.x + e.x, this.y + e.y, this.z + e.z) : super.add(e);
  }
  addTo(e) {
    super.addTo(e), e instanceof S && (this.z += e.z);
  }
  copy() {
    return S.clone(this);
  }
  div(e) {
    return S.create(this.x / e, this.y / e, this.z / e);
  }
  divTo(e) {
    super.divTo(e), this.z /= e;
  }
  mult(e) {
    return S.create(this.x * e, this.y * e, this.z * e);
  }
  multTo(e) {
    super.multTo(e), this.z *= e;
  }
  setTo(e) {
    super.setTo(e);
    const t = e;
    t.z !== void 0 && (this.z = t.z);
  }
  sub(e) {
    return e instanceof S ? S.create(this.x - e.x, this.y - e.y, this.z - e.z) : super.sub(e);
  }
  subFrom(e) {
    super.subFrom(e), e instanceof S && (this.z -= e.z);
  }
}
var ls = globalThis && globalThis.__classPrivateFieldSet || function(n, e, t, i, s) {
  if (i === "m")
    throw new TypeError("Private method is not writable");
  if (i === "a" && !s)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof e == "function" ? n !== e || !s : !e.has(n))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return i === "a" ? s.call(n, t) : s ? s.value = t : e.set(n, t), t;
}, Be = globalThis && globalThis.__classPrivateFieldGet || function(n, e, t, i) {
  if (t === "a" && !i)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof e == "function" ? n !== e || !i : !e.has(n))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return t === "m" ? i : t === "a" ? i.call(n) : i ? i.value : e.get(n);
}, he;
const wt = (n) => {
  !(ot(n.outMode, n.checkModes) || ot(n.outMode, n.checkModes)) || (n.coord > n.maxCoord - n.radius * 2 ? n.setCb(-n.radius) : n.coord < n.radius * 2 && n.setCb(n.radius));
};
class hs {
  constructor(e, t, i, s, o, r) {
    var a, l, c, u, d, h, p, f, v;
    this.id = t, this.container = i, this.group = r, he.set(this, void 0), ls(this, he, e, "f"), this.fill = !0, this.close = !0, this.lastPathTime = 0, this.destroyed = !1, this.unbreakable = !1, this.splitCount = 0, this.rotation = 0, this.misplaced = !1, this.retina = {
      maxDistance: {}
    }, this.outType = "normal", this.ignoresResizeRatio = !0;
    const m = i.retina.pixelRatio, w = i.actualOptions, M = et(Be(this, he, "f"), i, w.particles), A = M.shape.type, C = M.reduceDuplicates;
    if (this.shape = A instanceof Array ? Z(A, this.id, C) : A, o != null && o.shape) {
      if (o.shape.type) {
        const We = o.shape.type;
        this.shape = We instanceof Array ? Z(We, this.id, C) : We;
      }
      const D = new St();
      D.load(o.shape), this.shape && (this.shapeData = this.loadShapeData(D, C));
    } else
      this.shapeData = this.loadShapeData(M.shape, C);
    M.load(o), M.load((a = this.shapeData) === null || a === void 0 ? void 0 : a.particles), this.interactivity = new Mt(e, i), this.interactivity.load(i.actualOptions.interactivity), this.interactivity.load(M.interactivity), this.fill = (c = (l = this.shapeData) === null || l === void 0 ? void 0 : l.fill) !== null && c !== void 0 ? c : this.fill, this.close = (d = (u = this.shapeData) === null || u === void 0 ? void 0 : u.close) !== null && d !== void 0 ? d : this.close, this.options = M;
    const _ = this.options.move.path;
    this.pathDelay = Ue(_.delay) * 1e3, _.generator && (this.pathGenerator = Be(this, he, "f").plugins.getPathGenerator(_.generator), this.pathGenerator && i.addPath(_.generator, this.pathGenerator) && this.pathGenerator.init(i));
    const E = b(this.options.zIndex.value);
    i.retina.initParticle(this);
    const k = this.options.size, fe = k.value, B = k.animation;
    if (this.size = {
      enable: k.animation.enable,
      value: b(k.value) * i.retina.pixelRatio,
      max: De(fe) * m,
      min: Ae(fe) * m,
      loops: 0,
      maxLoops: b(k.animation.count)
    }, B.enable) {
      switch (this.size.status = 0, this.size.decay = 1 - b(B.decay), B.startValue) {
        case "min":
          this.size.value = this.size.min, this.size.status = 0;
          break;
        case "random":
          this.size.value = j(this.size) * m, this.size.status = W() >= 0.5 ? 0 : 1;
          break;
        case "max":
        default:
          this.size.value = this.size.max, this.size.status = 1;
          break;
      }
      this.size.velocity = ((h = this.retina.sizeAnimationSpeed) !== null && h !== void 0 ? h : i.retina.sizeAnimationSpeed) / 100 * i.retina.reduceFactor, B.sync || (this.size.velocity *= W());
    }
    this.bubble = {
      inRange: !1
    }, this.position = this.calcPosition(i, s, _t(E, 0, i.zLayers)), this.initialPosition = this.position.copy();
    const tt = i.canvas.size, it = this.options.move.center;
    switch (this.moveCenter = {
      x: tt.width * it.x / 100,
      y: tt.height * it.y / 100,
      radius: this.options.move.center.radius
    }, this.direction = Wt(this.options.move.direction, this.position, this.moveCenter), this.options.move.direction) {
      case "inside":
        this.outType = "inside";
        break;
      case "outside":
        this.outType = "outside";
        break;
    }
    this.initialVelocity = this.calculateVelocity(), this.velocity = this.initialVelocity.copy(), this.moveDecay = 1 - b(this.options.move.decay), this.offset = R.origin;
    const Se = i.particles;
    Se.needsSort = Se.needsSort || Se.lastZIndex < this.position.z, Se.lastZIndex = this.position.z, this.zIndexFactor = this.position.z / i.zLayers, this.sides = 24;
    let T = i.drawers.get(this.shape);
    T || (T = Be(this, he, "f").plugins.getShapeDrawer(this.shape), T && i.drawers.set(this.shape, T)), T != null && T.loadShape && (T == null || T.loadShape(this));
    const st = T == null ? void 0 : T.getSidesCount;
    st && (this.sides = st(this)), this.spawning = !1, this.shadowColor = de(this.options.shadow.color);
    for (const D of i.particles.updaters)
      (p = D.init) === null || p === void 0 || p.call(D, this);
    for (const D of i.particles.movers)
      (f = D.init) === null || f === void 0 || f.call(D, this);
    T != null && T.particleInit && T.particleInit(i, this);
    for (const [, D] of i.plugins)
      (v = D.particleCreated) === null || v === void 0 || v.call(D, this);
  }
  destroy(e) {
    if (this.unbreakable || this.destroyed)
      return;
    this.destroyed = !0, this.bubble.inRange = !1;
    for (const [, i] of this.container.plugins)
      i.particleDestroyed && i.particleDestroyed(this, e);
    if (e)
      return;
    this.options.destroy.mode === "split" && this.split();
  }
  draw(e) {
    const t = this.container;
    for (const [, i] of t.plugins)
      t.canvas.drawParticlePlugin(i, this, e);
    t.canvas.drawParticle(this, e);
  }
  getFillColor() {
    var e, t;
    const i = (e = this.bubble.color) !== null && e !== void 0 ? e : lt(this.color);
    if (i && this.roll && (this.backColor || this.roll.alter)) {
      const s = this.roll.horizontal && this.roll.vertical ? 2 : 1, o = this.roll.horizontal ? Math.PI / 2 : 0;
      if (Math.floor((((t = this.roll.angle) !== null && t !== void 0 ? t : 0) + o) / (Math.PI / s)) % 2) {
        if (this.backColor)
          return this.backColor;
        if (this.roll.alter)
          return si(i, this.roll.alter.type, this.roll.alter.value);
      }
    }
    return i;
  }
  getMass() {
    return this.getRadius() ** 2 * Math.PI / 2;
  }
  getPosition() {
    return {
      x: this.position.x + this.offset.x,
      y: this.position.y + this.offset.y,
      z: this.position.z
    };
  }
  getRadius() {
    var e;
    return (e = this.bubble.radius) !== null && e !== void 0 ? e : this.size.value;
  }
  getStrokeColor() {
    var e, t;
    return (t = (e = this.bubble.color) !== null && e !== void 0 ? e : lt(this.strokeColor)) !== null && t !== void 0 ? t : this.getFillColor();
  }
  isInsideCanvas() {
    const e = this.getRadius(), t = this.container.canvas.size;
    return this.position.x >= -e && this.position.y >= -e && this.position.y <= t.height + e && this.position.x <= t.width + e;
  }
  isVisible() {
    return !this.destroyed && !this.spawning && this.isInsideCanvas();
  }
  reset() {
    this.opacity && (this.opacity.loops = 0), this.size.loops = 0;
  }
  calcPosition(e, t, i, s = 0) {
    var o, r, a, l;
    for (const [, m] of e.plugins) {
      const w = m.particlePosition !== void 0 ? m.particlePosition(t, this) : void 0;
      if (w !== void 0)
        return S.create(w.x, w.y, i);
    }
    const c = e.canvas.size, u = $t({
      size: c,
      position: t
    }), d = S.create(u.x, u.y, i), h = this.getRadius(), p = this.options.move.outModes, f = (m) => {
      wt({
        outMode: m,
        checkModes: ["bounce", "bounce-horizontal"],
        coord: d.x,
        maxCoord: e.canvas.size.width,
        setCb: (w) => d.x += w,
        radius: h
      });
    }, v = (m) => {
      wt({
        outMode: m,
        checkModes: ["bounce", "bounce-vertical"],
        coord: d.y,
        maxCoord: e.canvas.size.height,
        setCb: (w) => d.y += w,
        radius: h
      });
    };
    return f((o = p.left) !== null && o !== void 0 ? o : p.default), f((r = p.right) !== null && r !== void 0 ? r : p.default), v((a = p.top) !== null && a !== void 0 ? a : p.default), v((l = p.bottom) !== null && l !== void 0 ? l : p.default), this.checkOverlap(d, s) ? this.calcPosition(e, void 0, i, s + 1) : d;
  }
  calculateVelocity() {
    const t = Ht(this.direction).copy(), i = this.options.move;
    if (i.direction === "inside" || i.direction === "outside")
      return t;
    const s = Math.PI / 180 * b(i.angle.value), o = Math.PI / 180 * b(i.angle.offset), r = {
      left: o - s / 2,
      right: o + s / 2
    };
    return i.straight || (t.angle += j(y(r.left, r.right))), i.random && typeof i.speed == "number" && (t.length *= W()), t;
  }
  checkOverlap(e, t = 0) {
    const i = this.options.collisions, s = this.getRadius();
    if (!i.enable)
      return !1;
    const o = i.overlap;
    if (o.enable)
      return !1;
    const r = o.retries;
    if (r >= 0 && t > r)
      throw new Error("Particle is overlapping and can't be placed");
    let a = !1;
    for (const l of this.container.particles.array)
      if (Ke(e, l.position) < s + l.getRadius()) {
        a = !0;
        break;
      }
    return a;
  }
  loadShapeData(e, t) {
    const i = e.options[this.shape];
    if (i)
      return z({}, i instanceof Array ? Z(i, this.id, t) : i);
  }
  split() {
    const e = this.options.destroy.split;
    if (e.count >= 0 && this.splitCount++ > e.count)
      return;
    const t = Ue(e.rate), i = e.particles instanceof Array ? Z(e.particles) : e.particles;
    for (let s = 0; s < t; s++)
      this.container.particles.addSplitParticle(this, i);
  }
}
he = /* @__PURE__ */ new WeakMap();
class cs {
  constructor(e, t) {
    this.position = e, this.particle = t;
  }
}
class kt {
  constructor(e, t) {
    this.position = {
      x: e,
      y: t
    };
  }
}
class Ze extends kt {
  constructor(e, t, i) {
    super(e, t), this.radius = i;
  }
  contains(e) {
    return Ke(e, this.position) <= this.radius;
  }
  intersects(e) {
    const t = e, i = e, s = this.position, o = e.position, r = Math.abs(o.x - s.x), a = Math.abs(o.y - s.y), l = this.radius;
    if (i.radius !== void 0) {
      const c = l + i.radius, u = Math.sqrt(r * r + a + a);
      return c > u;
    } else if (t.size !== void 0) {
      const c = t.size.width, u = t.size.height, d = Math.pow(r - c, 2) + Math.pow(a - u, 2);
      return r > l + c || a > l + u ? !1 : r <= c || a <= u ? !0 : d <= l * l;
    }
    return !1;
  }
}
class J extends kt {
  constructor(e, t, i, s) {
    super(e, t), this.size = {
      height: s,
      width: i
    };
  }
  contains(e) {
    const t = this.size.width, i = this.size.height, s = this.position;
    return e.x >= s.x && e.x <= s.x + t && e.y >= s.y && e.y <= s.y + i;
  }
  intersects(e) {
    const t = e, i = e, s = this.size.width, o = this.size.height, r = this.position, a = e.position;
    if (i.radius !== void 0)
      return i.intersects(this);
    if (!t.size)
      return !1;
    const l = t.size, c = l.width, u = l.height;
    return a.x < r.x + s && a.x + c > r.x && a.y < r.y + o && a.y + u > r.y;
  }
}
class us extends Ze {
  constructor(e, t, i, s) {
    super(e, t, i), this.canvasSize = s, this.canvasSize = Object.assign({}, s);
  }
  contains(e) {
    if (super.contains(e))
      return !0;
    const t = {
      x: e.x - this.canvasSize.width,
      y: e.y
    };
    if (super.contains(t))
      return !0;
    const i = {
      x: e.x - this.canvasSize.width,
      y: e.y - this.canvasSize.height
    };
    if (super.contains(i))
      return !0;
    const s = {
      x: e.x,
      y: e.y - this.canvasSize.height
    };
    return super.contains(s);
  }
  intersects(e) {
    if (super.intersects(e))
      return !0;
    const t = e, i = e, s = {
      x: e.position.x - this.canvasSize.width,
      y: e.position.y - this.canvasSize.height
    };
    if (i.radius !== void 0) {
      const o = new Ze(s.x, s.y, i.radius * 2);
      return super.intersects(o);
    } else if (t.size !== void 0) {
      const o = new J(s.x, s.y, t.size.width * 2, t.size.height * 2);
      return super.intersects(o);
    }
    return !1;
  }
}
class ne {
  constructor(e, t) {
    this.rectangle = e, this.capacity = t, this.points = [], this.divided = !1;
  }
  insert(e) {
    var t, i, s, o, r;
    return this.rectangle.contains(e.position) ? this.points.length < this.capacity ? (this.points.push(e), !0) : (this.divided || this.subdivide(), (r = ((t = this.northEast) === null || t === void 0 ? void 0 : t.insert(e)) || ((i = this.northWest) === null || i === void 0 ? void 0 : i.insert(e)) || ((s = this.southEast) === null || s === void 0 ? void 0 : s.insert(e)) || ((o = this.southWest) === null || o === void 0 ? void 0 : o.insert(e))) !== null && r !== void 0 ? r : !1) : !1;
  }
  query(e, t, i) {
    var s, o, r, a;
    const l = i != null ? i : [];
    if (!e.intersects(this.rectangle))
      return [];
    for (const c of this.points)
      !e.contains(c.position) && Ke(e.position, c.position) > c.particle.getRadius() && (!t || t(c.particle)) || l.push(c.particle);
    return this.divided && ((s = this.northEast) === null || s === void 0 || s.query(e, t, l), (o = this.northWest) === null || o === void 0 || o.query(e, t, l), (r = this.southEast) === null || r === void 0 || r.query(e, t, l), (a = this.southWest) === null || a === void 0 || a.query(e, t, l)), l;
  }
  queryCircle(e, t, i) {
    return this.query(new Ze(e.x, e.y, t), i);
  }
  queryCircleWarp(e, t, i, s) {
    const o = i, r = i;
    return this.query(new us(e.x, e.y, t, o.canvas !== void 0 ? o.canvas.size : r), s);
  }
  queryRectangle(e, t, i) {
    return this.query(new J(e.x, e.y, t.width, t.height), i);
  }
  subdivide() {
    const e = this.rectangle.position.x, t = this.rectangle.position.y, i = this.rectangle.size.width, s = this.rectangle.size.height, o = this.capacity;
    this.northEast = new ne(new J(e, t, i / 2, s / 2), o), this.northWest = new ne(new J(e + i / 2, t, i / 2, s / 2), o), this.southEast = new ne(new J(e, t + s / 2, i / 2, s / 2), o), this.southWest = new ne(new J(e + i / 2, t + s / 2, i / 2, s / 2), o), this.divided = !0;
  }
}
var ds = globalThis && globalThis.__classPrivateFieldSet || function(n, e, t, i, s) {
  if (i === "m")
    throw new TypeError("Private method is not writable");
  if (i === "a" && !s)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof e == "function" ? n !== e || !s : !e.has(n))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return i === "a" ? s.call(n, t) : s ? s.value = t : e.set(n, t), t;
}, U = globalThis && globalThis.__classPrivateFieldGet || function(n, e, t, i) {
  if (t === "a" && !i)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof e == "function" ? n !== e || !i : !e.has(n))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return t === "m" ? i : t === "a" ? i.call(n) : i ? i.value : e.get(n);
}, L;
class fs {
  constructor(e, t) {
    this.container = t, L.set(this, void 0), ds(this, L, e, "f"), this.nextId = 0, this.array = [], this.zArray = [], this.limit = 0, this.needsSort = !1, this.lastZIndex = 0, this.freqs = {
      links: /* @__PURE__ */ new Map(),
      triangles: /* @__PURE__ */ new Map()
    }, this.interactionManager = new as(U(this, L, "f"), t);
    const i = this.container.canvas.size;
    this.quadTree = new ne(new J(-i.width / 4, -i.height / 4, i.width * 3 / 2, i.height * 3 / 2), 4), this.movers = U(this, L, "f").plugins.getMovers(t, !0), this.updaters = U(this, L, "f").plugins.getUpdaters(t, !0);
  }
  get count() {
    return this.array.length;
  }
  addManualParticles() {
    const e = this.container, t = e.actualOptions;
    for (const i of t.manualParticles)
      this.addParticle(Vt({
        size: e.canvas.size,
        position: i.position
      }), i.options);
  }
  addParticle(e, t, i) {
    const s = this.container, o = s.actualOptions, r = o.particles.number.limit;
    if (r > 0) {
      const a = this.count + 1 - r;
      a > 0 && this.removeQuantity(a);
    }
    return this.pushParticle(e, t, i);
  }
  addSplitParticle(e, t) {
    const i = e.options.destroy.split, s = et(U(this, L, "f"), this.container, e.options), o = Ue(i.factor);
    s.color.load({
      value: {
        hsl: e.getFillColor()
      }
    }), typeof s.size.value == "number" ? s.size.value /= o : (s.size.value.min /= o, s.size.value.max /= o), s.load(t);
    const r = i.sizeOffset ? y(-e.size.value, e.size.value) : 0, a = {
      x: e.position.x + j(r),
      y: e.position.y + j(r)
    };
    return this.pushParticle(a, s, e.group, (l) => l.size.value < 0.5 ? !1 : (l.velocity.length = j(y(e.velocity.length, l.velocity.length)), l.splitCount = e.splitCount + 1, l.unbreakable = !0, setTimeout(() => {
      l.unbreakable = !1;
    }, 500), !0));
  }
  clear() {
    this.array = [], this.zArray = [];
  }
  destroy() {
    this.array = [], this.zArray = [], this.movers = [], this.updaters = [];
  }
  async draw(e) {
    const t = this.container, i = this.container.canvas.size;
    this.quadTree = new ne(new J(-i.width / 4, -i.height / 4, i.width * 3 / 2, i.height * 3 / 2), 4), t.canvas.clear(), await this.update(e), this.needsSort && (this.zArray.sort((s, o) => o.position.z - s.position.z || s.id - o.id), this.lastZIndex = this.zArray[this.zArray.length - 1].position.z, this.needsSort = !1);
    for (const [, s] of t.plugins)
      t.canvas.drawPlugin(s, e);
    for (const s of this.zArray)
      s.draw(e);
  }
  getLinkFrequency(e, t) {
    const i = y(e.id, t.id), s = `${Ae(i)}_${De(i)}`;
    let o = this.freqs.links.get(s);
    return o === void 0 && (o = W(), this.freqs.links.set(s, o)), o;
  }
  getTriangleFrequency(e, t, i) {
    let [s, o, r] = [e.id, t.id, i.id];
    s > o && ([o, s] = [s, o]), o > r && ([r, o] = [o, r]), s > r && ([r, s] = [s, r]);
    const a = `${s}_${o}_${r}`;
    let l = this.freqs.triangles.get(a);
    return l === void 0 && (l = W(), this.freqs.triangles.set(a, l)), l;
  }
  handleClickMode(e) {
    this.interactionManager.handleClickMode(e);
  }
  init() {
    var e;
    const t = this.container, i = t.actualOptions;
    this.lastZIndex = 0, this.needsSort = !1, this.freqs.links = /* @__PURE__ */ new Map(), this.freqs.triangles = /* @__PURE__ */ new Map();
    let s = !1;
    this.updaters = U(this, L, "f").plugins.getUpdaters(t, !0), this.interactionManager.init();
    for (const [, o] of t.plugins)
      if (o.particlesInitialization !== void 0 && (s = o.particlesInitialization()), s)
        break;
    this.interactionManager.init();
    for (const [, o] of t.pathGenerators)
      o.init(t);
    if (this.addManualParticles(), !s) {
      for (const o in i.particles.groups) {
        const r = i.particles.groups[o];
        for (let a = this.count, l = 0; l < ((e = r.number) === null || e === void 0 ? void 0 : e.value) && a < i.particles.number.value; a++, l++)
          this.addParticle(void 0, r, o);
      }
      for (let o = this.count; o < i.particles.number.value; o++)
        this.addParticle();
    }
  }
  push(e, t, i, s) {
    this.pushing = !0;
    for (let o = 0; o < e; o++)
      this.addParticle(t == null ? void 0 : t.position, i, s);
    this.pushing = !1;
  }
  async redraw() {
    this.clear(), this.init(), await this.draw({ value: 0, factor: 0 });
  }
  remove(e, t, i) {
    this.removeAt(this.array.indexOf(e), void 0, t, i);
  }
  removeAt(e, t = 1, i, s) {
    if (!(e >= 0 && e <= this.count))
      return;
    let o = 0;
    for (let r = e; o < t && r < this.count; r++) {
      const a = this.array[r];
      if (!a || a.group !== i)
        continue;
      a.destroy(s), this.array.splice(r--, 1);
      const l = this.zArray.indexOf(a);
      this.zArray.splice(l, 1), o++, U(this, L, "f").dispatchEvent("particleRemoved", {
        container: this.container,
        data: {
          particle: a
        }
      });
    }
  }
  removeQuantity(e, t) {
    this.removeAt(0, e, t);
  }
  setDensity() {
    const e = this.container.actualOptions;
    for (const t in e.particles.groups)
      this.applyDensity(e.particles.groups[t], 0, t);
    this.applyDensity(e.particles, e.manualParticles.length);
  }
  async update(e) {
    var t, i;
    const s = this.container, o = [];
    for (const [, r] of s.pathGenerators)
      r.update();
    for (const [, r] of s.plugins)
      (t = r.update) === null || t === void 0 || t.call(r, e);
    for (const r of this.array) {
      const a = s.canvas.resizeFactor;
      a && !r.ignoresResizeRatio && (r.position.x *= a.width, r.position.y *= a.height), r.ignoresResizeRatio = !1, await this.interactionManager.reset(r);
      for (const [, l] of this.container.plugins) {
        if (r.destroyed)
          break;
        (i = l.particleUpdate) === null || i === void 0 || i.call(l, r, e);
      }
      for (const l of this.movers)
        l.isEnabled(r) && l.move(r, e);
      if (r.destroyed) {
        o.push(r);
        continue;
      }
      this.quadTree.insert(new cs(r.getPosition(), r));
    }
    for (const r of o)
      this.remove(r);
    await this.interactionManager.externalInteract(e);
    for (const r of s.particles.array) {
      for (const a of this.updaters)
        a.update(r, e);
      !r.destroyed && !r.spawning && await this.interactionManager.particlesInteract(r, e);
    }
    delete s.canvas.resizeFactor;
  }
  applyDensity(e, t, i) {
    var s;
    if (!(!((s = e.number.density) === null || s === void 0) && s.enable))
      return;
    const o = e.number, r = this.initDensityFactor(o.density), a = o.value, l = o.limit > 0 ? o.limit : a, c = Math.min(a, l) * r + t, u = Math.min(this.count, this.array.filter((d) => d.group === i).length);
    this.limit = o.limit * r, u < c ? this.push(Math.abs(c - u), void 0, e, i) : u > c && this.removeQuantity(u - c, i);
  }
  initDensityFactor(e) {
    const t = this.container;
    if (!t.canvas.element || !e.enable)
      return 1;
    const i = t.canvas.element, s = t.retina.pixelRatio;
    return i.width * i.height / (e.factor * s ** 2 * e.area);
  }
  pushParticle(e, t, i, s) {
    try {
      const o = new hs(U(this, L, "f"), this.nextId, this.container, e, t, i);
      let r = !0;
      return s && (r = s(o)), r ? (this.array.push(o), this.zArray.push(o), this.nextId++, U(this, L, "f").dispatchEvent("particleAdded", {
        container: this.container,
        data: {
          particle: o
        }
      }), o) : void 0;
    } catch (o) {
      console.warn(`error adding particle: ${o}`);
      return;
    }
  }
}
L = /* @__PURE__ */ new WeakMap();
class ps {
  constructor(e) {
    this.container = e;
  }
  init() {
    const e = this.container, t = e.actualOptions;
    this.pixelRatio = !t.detectRetina || Te() ? 1 : window.devicePixelRatio;
    const i = this.container.actualOptions.motion;
    if (i && (i.disable || i.reduce.value))
      if (Te() || typeof matchMedia > "u" || !matchMedia)
        this.reduceFactor = 1;
      else {
        const a = matchMedia("(prefers-reduced-motion: reduce)");
        if (a) {
          this.handleMotionChange(a);
          const l = () => {
            this.handleMotionChange(a), e.refresh().catch(() => {
            });
          };
          a.addEventListener !== void 0 ? a.addEventListener("change", l) : a.addListener !== void 0 && a.addListener(l);
        }
      }
    else
      this.reduceFactor = 1;
    const s = this.pixelRatio;
    if (e.canvas.element) {
      const a = e.canvas.element;
      e.canvas.size.width = a.offsetWidth * s, e.canvas.size.height = a.offsetHeight * s;
    }
    const o = t.particles;
    this.attractDistance = b(o.move.attract.distance) * s, this.sizeAnimationSpeed = b(o.size.animation.speed) * s, this.maxSpeed = b(o.move.gravity.maxSpeed) * s;
    const r = t.interactivity.modes;
    this.slowModeRadius = r.slow.radius * s;
  }
  initParticle(e) {
    const t = e.options, i = this.pixelRatio, s = t.move.distance, o = e.retina;
    o.attractDistance = b(t.move.attract.distance) * i, o.moveDrift = b(t.move.drift) * i, o.moveSpeed = b(t.move.speed) * i, o.sizeAnimationSpeed = b(t.size.animation.speed) * i;
    const r = o.maxDistance;
    r.horizontal = s.horizontal !== void 0 ? s.horizontal * i : void 0, r.vertical = s.vertical !== void 0 ? s.vertical * i : void 0, o.maxSpeed = b(t.move.gravity.maxSpeed) * i;
  }
  handleMotionChange(e) {
    const t = this.container.actualOptions;
    if (e.matches) {
      const i = t.motion;
      this.reduceFactor = i.disable ? 0 : i.reduce.value ? 1 / i.reduce.factor : 1;
    } else
      this.reduceFactor = 1;
  }
}
var X = globalThis && globalThis.__classPrivateFieldSet || function(n, e, t, i, s) {
  if (i === "m")
    throw new TypeError("Private method is not writable");
  if (i === "a" && !s)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof e == "function" ? n !== e || !s : !e.has(n))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return i === "a" ? s.call(n, t) : s ? s.value = t : e.set(n, t), t;
}, g = globalThis && globalThis.__classPrivateFieldGet || function(n, e, t, i) {
  if (t === "a" && !i)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof e == "function" ? n !== e || !i : !e.has(n))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return t === "m" ? i : t === "a" ? i.call(n) : i ? i.value : e.get(n);
}, x, _e, se, G, Pe;
function P(n) {
  return !n.destroyed;
}
function me(n, e, ...t) {
  const i = new rs(n, e);
  return Et(i, ...t), i;
}
const ms = "default", bt = {
  generate: (n) => {
    const e = n.velocity.copy();
    return e.angle += e.length * Math.PI / 180, e;
  },
  init: () => {
  },
  update: () => {
  }
};
class vs {
  constructor(e, t, i) {
    this.id = t, x.set(this, void 0), _e.set(this, void 0), se.set(this, void 0), G.set(this, void 0), Pe.set(this, void 0), X(this, x, e, "f"), this.fpsLimit = 120, this.duration = 0, this.lifeTime = 0, this.firstStart = !0, this.started = !1, this.destroyed = !1, this.paused = !0, this.lastFrameTime = 0, this.zLayers = 100, this.pageHidden = !1, X(this, Pe, i, "f"), this._initialSourceOptions = i, this.retina = new ps(this), this.canvas = new fi(this), this.particles = new fs(g(this, x, "f"), this), this.frameManager = new mi(this), this.pathGenerators = /* @__PURE__ */ new Map(), this.interactivity = {
      mouse: {
        clicking: !1,
        inside: !1
      }
    }, this.plugins = /* @__PURE__ */ new Map(), this.drawers = /* @__PURE__ */ new Map(), X(this, G, me(g(this, x, "f"), this), "f"), this.actualOptions = me(g(this, x, "f"), this), X(this, _e, new pi(this), "f"), typeof IntersectionObserver < "u" && IntersectionObserver && X(this, se, new IntersectionObserver((s) => this.intersectionManager(s)), "f"), g(this, x, "f").dispatchEvent("containerBuilt", { container: this });
  }
  get options() {
    return g(this, G, "f");
  }
  get sourceOptions() {
    return g(this, Pe, "f");
  }
  addClickHandler(e) {
    if (!P(this))
      return;
    const t = this.interactivity.element;
    if (!t)
      return;
    const i = (d, h, p) => {
      if (!P(this))
        return;
      const f = this.retina.pixelRatio, v = {
        x: h.x * f,
        y: h.y * f
      }, m = this.particles.quadTree.queryCircle(v, p * f);
      e(d, m);
    }, s = (d) => {
      if (!P(this))
        return;
      const h = d, p = {
        x: h.offsetX || h.clientX,
        y: h.offsetY || h.clientY
      };
      i(d, p, 1);
    }, o = () => {
      !P(this) || (c = !0, u = !1);
    }, r = () => {
      !P(this) || (u = !0);
    }, a = (d) => {
      var h, p, f;
      if (!!P(this)) {
        if (c && !u) {
          const v = d;
          let m = v.touches[v.touches.length - 1];
          if (!m && (m = v.changedTouches[v.changedTouches.length - 1], !m))
            return;
          const w = (h = this.canvas.element) === null || h === void 0 ? void 0 : h.getBoundingClientRect(), M = {
            x: m.clientX - ((p = w == null ? void 0 : w.left) !== null && p !== void 0 ? p : 0),
            y: m.clientY - ((f = w == null ? void 0 : w.top) !== null && f !== void 0 ? f : 0)
          };
          i(d, M, Math.max(m.radiusX, m.radiusY));
        }
        c = !1, u = !1;
      }
    }, l = () => {
      !P(this) || (c = !1, u = !1);
    };
    let c = !1, u = !1;
    t.addEventListener("click", s), t.addEventListener("touchstart", o), t.addEventListener("touchmove", r), t.addEventListener("touchend", a), t.addEventListener("touchcancel", l);
  }
  addPath(e, t, i = !1) {
    return !P(this) || !i && this.pathGenerators.has(e) ? !1 : (this.pathGenerators.set(e, t != null ? t : bt), !0);
  }
  destroy() {
    if (!P(this))
      return;
    this.stop(), this.particles.destroy(), this.canvas.destroy();
    for (const [, i] of this.drawers)
      i.destroy && i.destroy(this);
    for (const i of this.drawers.keys())
      this.drawers.delete(i);
    g(this, x, "f").plugins.destroy(this), this.destroyed = !0;
    const e = g(this, x, "f").dom(), t = e.findIndex((i) => i === this);
    t >= 0 && e.splice(t, 1), g(this, x, "f").dispatchEvent("containerDestroyed", { container: this });
  }
  draw(e) {
    if (!P(this))
      return;
    let t = e;
    this.drawAnimationFrame = qt()(async (i) => {
      t && (this.lastFrameTime = void 0, t = !1), await this.frameManager.nextFrame(i);
    });
  }
  exportConfiguration() {
    return JSON.stringify(this.actualOptions, void 0, 2);
  }
  exportImage(e, t, i) {
    var s;
    return (s = this.canvas.element) === null || s === void 0 ? void 0 : s.toBlob(e, t != null ? t : "image/png", i);
  }
  exportImg(e) {
    this.exportImage(e);
  }
  getAnimationStatus() {
    return !this.paused && !this.pageHidden && P(this);
  }
  handleClickMode(e) {
    if (!!P(this)) {
      this.particles.handleClickMode(e);
      for (const [, t] of this.plugins)
        t.handleClickMode && t.handleClickMode(e);
    }
  }
  async init() {
    if (!P(this))
      return;
    const e = g(this, x, "f").plugins.getSupportedShapes();
    for (const i of e) {
      const s = g(this, x, "f").plugins.getShapeDrawer(i);
      s && this.drawers.set(i, s);
    }
    X(this, G, me(g(this, x, "f"), this, this._initialSourceOptions, this.sourceOptions), "f"), this.actualOptions = me(g(this, x, "f"), this, g(this, G, "f")), this.retina.init(), this.canvas.init(), this.updateActualOptions(), this.canvas.initBackground(), this.canvas.resize(), this.zLayers = this.actualOptions.zLayers, this.duration = b(this.actualOptions.duration), this.lifeTime = 0, this.fpsLimit = this.actualOptions.fpsLimit > 0 ? this.actualOptions.fpsLimit : 120;
    const t = g(this, x, "f").plugins.getAvailablePlugins(this);
    for (const [i, s] of t)
      this.plugins.set(i, s);
    for (const [, i] of this.drawers)
      i.init && await i.init(this);
    for (const [, i] of this.plugins)
      i.init ? i.init(this.actualOptions) : i.initAsync !== void 0 && await i.initAsync(this.actualOptions);
    g(this, x, "f").dispatchEvent("containerInit", { container: this }), this.particles.init(), this.particles.setDensity();
    for (const [, i] of this.plugins)
      i.particlesSetup !== void 0 && i.particlesSetup();
    g(this, x, "f").dispatchEvent("particlesSetup", { container: this });
  }
  async loadTheme(e) {
    !P(this) || (this.currentTheme = e, await this.refresh());
  }
  pause() {
    if (!!P(this) && (this.drawAnimationFrame !== void 0 && (Gt()(this.drawAnimationFrame), delete this.drawAnimationFrame), !this.paused)) {
      for (const [, e] of this.plugins)
        e.pause && e.pause();
      this.pageHidden || (this.paused = !0), g(this, x, "f").dispatchEvent("containerPaused", { container: this });
    }
  }
  play(e) {
    if (!P(this))
      return;
    const t = this.paused || e;
    if (this.firstStart && !this.actualOptions.autoPlay) {
      this.firstStart = !1;
      return;
    }
    if (this.paused && (this.paused = !1), t)
      for (const [, i] of this.plugins)
        i.play && i.play();
    g(this, x, "f").dispatchEvent("containerPlay", { container: this }), this.draw(t || !1);
  }
  async refresh() {
    if (!!P(this))
      return this.stop(), this.start();
  }
  async reset() {
    if (!!P(this))
      return X(this, G, me(g(this, x, "f"), this), "f"), this.refresh();
  }
  setNoise(e, t, i) {
    !P(this) || this.setPath(e, t, i);
  }
  setPath(e, t, i) {
    if (!e || !P(this))
      return;
    const s = Object.assign({}, bt);
    if (typeof e == "function")
      s.generate = e, t && (s.init = t), i && (s.update = i);
    else {
      const o = s;
      s.generate = e.generate || o.generate, s.init = e.init || o.init, s.update = e.update || o.update;
    }
    this.addPath(ms, s, !0);
  }
  async start() {
    if (!(this.started || !P(this))) {
      await this.init(), this.started = !0, g(this, _e, "f").addListeners(), this.interactivity.element instanceof HTMLElement && g(this, se, "f") && g(this, se, "f").observe(this.interactivity.element);
      for (const [, e] of this.plugins)
        e.startAsync !== void 0 ? await e.startAsync() : e.start !== void 0 && e.start();
      g(this, x, "f").dispatchEvent("containerStarted", { container: this }), this.play();
    }
  }
  stop() {
    var e;
    if (!(!this.started || !P(this))) {
      this.firstStart = !0, this.started = !1, g(this, _e, "f").removeListeners(), this.pause(), this.particles.clear(), this.canvas.clear(), this.interactivity.element instanceof HTMLElement && g(this, se, "f") && g(this, se, "f").unobserve(this.interactivity.element);
      for (const [, t] of this.plugins)
        (e = t.stop) === null || e === void 0 || e.call(t);
      for (const t of this.plugins.keys())
        this.plugins.delete(t);
      X(this, Pe, g(this, G, "f"), "f"), g(this, x, "f").dispatchEvent("containerStopped", { container: this });
    }
  }
  updateActualOptions() {
    this.actualOptions.responsive = [];
    const e = this.actualOptions.setResponsive(this.canvas.size.width, this.retina.pixelRatio, g(this, G, "f"));
    return this.actualOptions.setTheme(this.currentTheme), this.responsiveMaxWidth != e ? (this.responsiveMaxWidth = e, !0) : !1;
  }
  intersectionManager(e) {
    if (!!this.actualOptions.pauseOnOutsideViewport)
      for (const t of e)
        t.target === this.interactivity.element && (t.isIntersecting ? this.play : this.pause)();
  }
}
x = /* @__PURE__ */ new WeakMap(), _e = /* @__PURE__ */ new WeakMap(), se = /* @__PURE__ */ new WeakMap(), G = /* @__PURE__ */ new WeakMap(), Pe = /* @__PURE__ */ new WeakMap();
var gs = globalThis && globalThis.__classPrivateFieldSet || function(n, e, t, i, s) {
  if (i === "m")
    throw new TypeError("Private method is not writable");
  if (i === "a" && !s)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof e == "function" ? n !== e || !s : !e.has(n))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return i === "a" ? s.call(n, t) : s ? s.value = t : e.set(n, t), t;
}, Ne = globalThis && globalThis.__classPrivateFieldGet || function(n, e, t, i) {
  if (t === "a" && !i)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof e == "function" ? n !== e || !i : !e.has(n))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return t === "m" ? i : t === "a" ? i.call(n) : i ? i.value : e.get(n);
}, ce;
function ys(n) {
  console.error(`tsParticles - Error ${n} while retrieving config file`);
}
async function ws(n, e) {
  const t = n instanceof Array ? Z(n, e) : n;
  if (!t)
    return;
  const i = await fetch(t);
  if (i.ok)
    return i.json();
  ys(i.status);
}
class bs {
  constructor(e) {
    ce.set(this, void 0), gs(this, ce, e, "f");
  }
  load(e, t, i) {
    const s = { index: i, remote: !1 };
    return typeof e == "string" ? s.tagId = e : s.options = e, typeof t == "number" ? s.index = t : s.options = t != null ? t : s.options, this.loadOptions(s);
  }
  async loadJSON(e, t, i) {
    let s, o;
    return typeof t == "number" || t === void 0 ? s = e : (o = e, s = t), this.loadRemoteOptions({ tagId: o, url: s, index: i, remote: !0 });
  }
  async loadOptions(e) {
    var t, i, s;
    const o = (t = e.tagId) !== null && t !== void 0 ? t : `tsparticles${Math.floor(W() * 1e4)}`, { index: r, url: a, remote: l } = e, c = l ? await ws(a, r) : e.options;
    let u = (i = e.element) !== null && i !== void 0 ? i : document.getElementById(o);
    u || (u = document.createElement("div"), u.id = o, (s = document.querySelector("body")) === null || s === void 0 || s.append(u));
    const d = c instanceof Array ? Z(c, r) : c, h = Ne(this, ce, "f").dom(), p = h.findIndex((m) => m.id === o);
    if (p >= 0) {
      const m = Ne(this, ce, "f").domItem(p);
      m && !m.destroyed && (m.destroy(), h.splice(p, 1));
    }
    let f;
    if (u.tagName.toLowerCase() === "canvas")
      f = u, f.dataset[Me] = "false";
    else {
      const m = u.getElementsByTagName("canvas");
      m.length ? (f = m[0], f.dataset[Me] = "false") : (f = document.createElement("canvas"), f.dataset[Me] = "true", u.appendChild(f));
    }
    f.style.width || (f.style.width = "100%"), f.style.height || (f.style.height = "100%");
    const v = new vs(Ne(this, ce, "f"), o, d);
    return p >= 0 ? h.splice(p, 0, v) : h.push(v), v.canvas.loadCanvas(f), await v.start(), v;
  }
  async loadRemoteOptions(e) {
    return this.loadOptions(e);
  }
  async set(e, t, i, s) {
    const o = { index: s, remote: !1 };
    return typeof e == "string" ? o.tagId = e : o.element = e, t instanceof HTMLElement ? o.element = t : o.options = t, typeof i == "number" ? o.index = i : o.options = i != null ? i : o.options, this.loadOptions(o);
  }
  async setJSON(e, t, i, s) {
    let o, r, a, l;
    return e instanceof HTMLElement ? (l = e, o = t, a = i) : (r = e, l = t, o = i, a = s), this.loadRemoteOptions({ tagId: r, url: o, index: a, element: l, remote: !0 });
  }
}
ce = /* @__PURE__ */ new WeakMap();
var _s = globalThis && globalThis.__classPrivateFieldSet || function(n, e, t, i, s) {
  if (i === "m")
    throw new TypeError("Private method is not writable");
  if (i === "a" && !s)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof e == "function" ? n !== e || !s : !e.has(n))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return i === "a" ? s.call(n, t) : s ? s.value = t : e.set(n, t), t;
}, Qe;
class Ps {
  constructor(e) {
    Qe.set(this, void 0), _s(this, Qe, e, "f"), this.plugins = [], this.interactorsInitializers = /* @__PURE__ */ new Map(), this.moversInitializers = /* @__PURE__ */ new Map(), this.updatersInitializers = /* @__PURE__ */ new Map(), this.interactors = /* @__PURE__ */ new Map(), this.movers = /* @__PURE__ */ new Map(), this.updaters = /* @__PURE__ */ new Map(), this.presets = /* @__PURE__ */ new Map(), this.drawers = /* @__PURE__ */ new Map(), this.pathGenerators = /* @__PURE__ */ new Map();
  }
  addInteractor(e, t) {
    this.interactorsInitializers.set(e, t);
  }
  addParticleMover(e, t) {
    this.moversInitializers.set(e, t);
  }
  addParticleUpdater(e, t) {
    this.updatersInitializers.set(e, t);
  }
  addPathGenerator(e, t) {
    this.getPathGenerator(e) || this.pathGenerators.set(e, t);
  }
  addPlugin(e) {
    this.getPlugin(e.id) || this.plugins.push(e);
  }
  addPreset(e, t, i = !1) {
    (i || !this.getPreset(e)) && this.presets.set(e, t);
  }
  addShapeDrawer(e, t) {
    this.getShapeDrawer(e) || this.drawers.set(e, t);
  }
  destroy(e) {
    this.updaters.delete(e), this.movers.delete(e), this.interactors.delete(e);
  }
  getAvailablePlugins(e) {
    const t = /* @__PURE__ */ new Map();
    for (const i of this.plugins)
      !i.needsPlugin(e.actualOptions) || t.set(i.id, i.getPlugin(e));
    return t;
  }
  getInteractors(e, t = !1) {
    let i = this.interactors.get(e);
    return (!i || t) && (i = [...this.interactorsInitializers.values()].map((s) => s(e)), this.interactors.set(e, i)), i;
  }
  getMovers(e, t = !1) {
    let i = this.movers.get(e);
    return (!i || t) && (i = [...this.moversInitializers.values()].map((s) => s(e)), this.movers.set(e, i)), i;
  }
  getPathGenerator(e) {
    return this.pathGenerators.get(e);
  }
  getPlugin(e) {
    return this.plugins.find((t) => t.id === e);
  }
  getPreset(e) {
    return this.presets.get(e);
  }
  getShapeDrawer(e) {
    return this.drawers.get(e);
  }
  getSupportedShapes() {
    return this.drawers.keys();
  }
  getUpdaters(e, t = !1) {
    let i = this.updaters.get(e);
    return (!i || t) && (i = [...this.updatersInitializers.values()].map((s) => s(e)), this.updaters.set(e, i)), i;
  }
  loadOptions(e, t) {
    for (const i of this.plugins)
      i.loadOptions(e, t);
  }
  loadParticlesOptions(e, t, ...i) {
    const s = this.updaters.get(e);
    if (!!s)
      for (const o of s)
        o.loadOptions && o.loadOptions(t, ...i);
  }
}
Qe = /* @__PURE__ */ new WeakMap();
var ve = globalThis && globalThis.__classPrivateFieldSet || function(n, e, t, i, s) {
  if (i === "m")
    throw new TypeError("Private method is not writable");
  if (i === "a" && !s)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof e == "function" ? n !== e || !s : !e.has(n))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return i === "a" ? s.call(n, t) : s ? s.value = t : e.set(n, t), t;
}, $ = globalThis && globalThis.__classPrivateFieldGet || function(n, e, t, i) {
  if (t === "a" && !i)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof e == "function" ? n !== e || !i : !e.has(n))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return t === "m" ? i : t === "a" ? i.call(n) : i ? i.value : e.get(n);
}, Ie, ue, xe, Y;
class xs {
  constructor() {
    Ie.set(this, void 0), ue.set(this, void 0), xe.set(this, void 0), Y.set(this, void 0), ve(this, Ie, [], "f"), ve(this, ue, new At(), "f"), ve(this, xe, !1, "f"), ve(this, Y, new bs(this), "f"), this.plugins = new Ps(this);
  }
  addEventListener(e, t) {
    $(this, ue, "f").addEventListener(e, t);
  }
  async addInteractor(e, t) {
    this.plugins.addInteractor(e, t), await this.refresh();
  }
  async addMover(e, t) {
    this.plugins.addParticleMover(e, t), await this.refresh();
  }
  async addParticleUpdater(e, t) {
    this.plugins.addParticleUpdater(e, t), await this.refresh();
  }
  async addPathGenerator(e, t) {
    this.plugins.addPathGenerator(e, t), await this.refresh();
  }
  async addPlugin(e) {
    this.plugins.addPlugin(e), await this.refresh();
  }
  async addPreset(e, t, i = !1) {
    this.plugins.addPreset(e, t, i), await this.refresh();
  }
  async addShape(e, t, i, s, o) {
    let r;
    typeof t == "function" ? r = {
      afterEffect: s,
      destroy: o,
      draw: t,
      init: i
    } : r = t, this.plugins.addShapeDrawer(e, r), await this.refresh();
  }
  dispatchEvent(e, t) {
    $(this, ue, "f").dispatchEvent(e, t);
  }
  dom() {
    return $(this, Ie, "f");
  }
  domItem(e) {
    const t = this.dom(), i = t[e];
    if (i && !i.destroyed)
      return i;
    t.splice(e, 1);
  }
  init() {
    $(this, xe, "f") || ve(this, xe, !0, "f");
  }
  async load(e, t) {
    return $(this, Y, "f").load(e, t);
  }
  async loadFromArray(e, t, i) {
    return $(this, Y, "f").load(e, t, i);
  }
  async loadJSON(e, t, i) {
    return $(this, Y, "f").loadJSON(e, t, i);
  }
  async refresh() {
    for (const e of this.dom())
      await e.refresh();
  }
  removeEventListener(e, t) {
    $(this, ue, "f").removeEventListener(e, t);
  }
  async set(e, t, i) {
    return $(this, Y, "f").set(e, t, i);
  }
  async setJSON(e, t, i, s) {
    return $(this, Y, "f").setJSON(e, t, i, s);
  }
  setOnClickHandler(e) {
    const t = this.dom();
    if (!t.length)
      throw new Error("Can only set click handlers after calling tsParticles.load() or tsParticles.loadJSON()");
    for (const i of t)
      i.addClickHandler(e);
  }
}
Ie = /* @__PURE__ */ new WeakMap(), ue = /* @__PURE__ */ new WeakMap(), xe = /* @__PURE__ */ new WeakMap(), Y = /* @__PURE__ */ new WeakMap();
class zs {
  constructor() {
    this.stringPrefix = "hsl";
  }
  handleColor(e) {
    var t;
    const i = e.value, s = (t = i.hsl) !== null && t !== void 0 ? t : e.value;
    if (s.h !== void 0 && s.l !== void 0)
      return Xe(s);
  }
  handleRangeColor(e) {
    var t;
    const i = e.value, s = (t = i.hsl) !== null && t !== void 0 ? t : e.value;
    if (s.h !== void 0 && s.l !== void 0)
      return Xe({
        h: b(s.h),
        l: b(s.l),
        s: b(s.s)
      });
  }
  parseString(e) {
    if (!e.startsWith("hsl"))
      return;
    const t = /hsla?\(\s*(\d+)\s*,\s*(\d+)%\s*,\s*(\d+)%\s*(,\s*([\d.%]+)\s*)?\)/i, i = t.exec(e);
    return i ? Yt({
      a: i.length > 4 ? Pt(i[5]) : 1,
      h: parseInt(i[1], 10),
      l: parseInt(i[3], 10),
      s: parseInt(i[2], 10)
    }) : void 0;
  }
}
class Ms {
  constructor() {
    this.stringPrefix = "rgb";
  }
  handleColor(e) {
    var t;
    const i = e.value, s = (t = i.rgb) !== null && t !== void 0 ? t : e.value;
    if (s.r !== void 0)
      return s;
  }
  handleRangeColor(e) {
    var t;
    const i = e.value, s = (t = i.rgb) !== null && t !== void 0 ? t : e.value;
    if (s.r !== void 0)
      return {
        r: b(s.r),
        g: b(s.g),
        b: b(s.b)
      };
  }
  parseString(e) {
    if (!e.startsWith(this.stringPrefix))
      return;
    const t = /rgba?\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([\d.%]+)\s*)?\)/i, i = t.exec(e);
    return i ? {
      a: i.length > 4 ? Pt(i[5]) : 1,
      b: parseInt(i[3], 10),
      g: parseInt(i[2], 10),
      r: parseInt(i[1], 10)
    } : void 0;
  }
}
const Ts = new Ms(), Cs = new zs();
xt("rgb", Ts);
xt("hsl", Cs);
const ze = new xs();
ze.init();
let oe;
const Ss = Ot({
  name: "Particles",
  props: {
    id: {
      type: String,
      required: !0
    },
    options: {
      type: Object
    },
    url: {
      type: String
    },
    particlesLoaded: {
      type: Function
    },
    particlesInit: {
      type: Function
    }
  },
  mounted() {
    Rt(async () => {
      var t;
      if (!this.id)
        throw new Error("Prop 'id' is required!");
      ze.init(), this.particlesInit && await this.particlesInit(ze);
      const n = (i) => {
        oe = i, this.particlesLoaded && oe && this.particlesLoaded(oe);
      }, e = await (this.url ? ze.loadJSON(this.id, this.url) : ze.load(this.id, (t = this.options) != null ? t : {}));
      n(e);
    });
  },
  unmounted() {
    oe && (oe.destroy(), oe = void 0);
  }
}), Es = (n, e) => {
  const t = n.__vccOpts || n;
  for (const [i, s] of e)
    t[i] = s;
  return t;
}, ks = ["id"];
function Os(n, e, t, i, s, o) {
  return Ft(), It("div", { id: n.id }, null, 8, ks);
}
const Rs = /* @__PURE__ */ Es(Ss, [["render", Os]]), Is = (n, e) => {
  n.component("Particles", Rs);
};
export {
  Rs as ParticlesComponent,
  Is as default
};
